<?xml version="1.0" encoding="UTF-8"?>
<chapter id="validator-checkconstraints">
  <title>Using the Validator framework</title>

  <para>Hibernate Validator is intended to be used to implement multi-layered
  data validation, where constraints are expressed in a single place (the
  annotated domain model) and checked in various different layers of the
  application.</para>

  <para>This chapter will cover Hibernate Validator usage for different
  layers</para>

  <section id="validator-checkconstraints-db" revision="2">
    <title>Database schema-level validation</title>

    <para>Out of the box, Hibernate Annotations will translate the constraints
    you have defined for your entities into mapping metadata. For example, if
    a property of your entity is annotated <literal>@NotNull</literal>, its
    columns will be declared as <literal>not null</literal> in the DDL schema
    generated by Hibernate.</para>

    <para>Using hbm2ddl, domain model constraints will be expressed into the
    database schema.</para>

    <para>If, for some reason, the feature needs to be disabled, set
    <literal>hibernate.validator.apply_to_ddl</literal> to
    <literal>false</literal>.</para>
  </section>

  <section id="validator-checkconstraints-orm">
    <title>ORM integration</title>

    <para>Hibernate Validator integrates with both Hibernate and all pure Java
    Persistence providers</para>

    <section id="validator-checkconstraints-orm-hibernateevent" revision="1">
      <title>Hibernate event-based validation</title>

      <para>Hibernate Validator has two built-in Hibernate event listeners.
      Whenever a <literal>PreInsertEvent</literal> or
      <literal>PreUpdateEvent</literal> occurs, the listeners will verify all
      constraints of the entity instance and throw an exception if any
      constraint is violated. Basically, objects will be checked before any
      inserts and before any updates made by Hibernate. This includes changes
      applied by cascade! This is the most convenient and the easiest way to
      activate the validation process. On constraint violation, the event will
      raise a runtime <classname>InvalidStateException</classname> which
      contains an array of <literal>InvalidValue</literal>s describing each
      failure.</para>

      <para>If Hibernate Validator is present in the classpath, Hibernate
      Annotations (or Hibernate EntityManager) will use it transparently. If,
      for some reason, you want to disable this integration, set
      <literal>hibernate.validator.autoregister_listeners</literal> to
      false</para>

      <para><note>
          <para>If the beans are not annotated with validation annotations,
          there is no runtime performance cost.</para>
        </note></para>

      <para>In case you need to manually set the event listeners for Hibernate
      Core, use the following configuration in
      <literal>hibernate.cfg.xml</literal>:</para>

      <programlisting>&lt;hibernate-configuration&gt;
    ...
    &lt;event type="pre-update"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidateEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-insert"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidateEventListener"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </section>

    <section id="validator-checkconstraints-orm-jpaevent">
      <title>Java Persistence event-based validation</title>

      <para>Hibernate Validator is not tied to Hibernate for event based
      validation: a Java Persistence entity listener is available. Whenever an
      listened entity is persisted or updated, Hibernate Validator will verify
      all constraints of the entity instance and throw an exception if any
      constraint is violated. Basically, objects will be checked before any
      inserts and before any updates made by the Java Persistence provider.
      This includes changes applied by cascade! On constraint violation, the
      event will raise a runtime <classname>InvalidStateException</classname>
      which contains an array of <literal>InvalidValue</literal>s describing
      each failure.</para>

      <para>Here is how to make a class validatable:</para>

      <programlisting>@Entity
@EntityListeners( JPAValidateListener.class )
public class Submarine {
    ...
}</programlisting>

      <para><note>
          <para>Compared to the Hibernate event, the Java Persistence listener
          has two drawbacks. You need to define the entity listener on every
          validatable entity. The DDL generated by your provider will not
          reflect the constraints.</para>
        </note></para>
    </section>
  </section>

  <section>
    <title>Application-level validation</title>

    <para>Hibernate Validator can be applied anywhere in your application
    code.</para>

    <programlisting>ClassValidator personValidator = new ClassValidator( Person.class );
ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

InvalidValue[] validationMessages = addressValidator.getInvalidValues(address);</programlisting>

    <para>The first two lines prepare the Hibernate Validator for class
    checking. The first one relies upon the error messages embedded in
    Hibernate Validator (see <xref
    linkend="validator-defineconstraints-error" />), the second one uses a
    resource bundle for these messages. It is considered a good practice to
    execute these lines once and cache the validator instances.</para>

    <para>The third line actually validates the <literal>Address</literal>
    instance and returns an array of <literal>InvalidValue</literal>s. Your
    application logic will then be able to react to the failure.</para>

    <para>You can also check a particular property instead of the whole bean.
    This might be useful for property per property user interaction</para>

    <programlisting>ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

//only get city property invalid values
InvalidValue[] validationMessages = addressValidator.getInvalidValues(address, "city");

//only get potential city property invalid values
InvalidValue[] validationMessages = addressValidator.getPotentialInvalidValues("city", "Paris")</programlisting>
  </section>

  <section>
    <title>Presentation layer validation</title>

    <para>When working with JSF and <productname>JBoss Seam</productname>, one
    can triggers the validation process at the presentation layer using Seam's
    JSF tags <literal>&lt;s:validate&gt;</literal> and
    <literal>&lt;s:validateAll/&gt;</literal>, letting the constraints be
    expressed on the model, and the violations presented in the view</para>

    <programlisting>&lt;h:form&gt;
    &lt;div&gt;
        &lt;h:messages/&gt;
    &lt;/div&gt;
    <emphasis role="bold">&lt;s:validateAll&gt;</emphasis>
        &lt;div&gt;
            Country:
            &lt;h:inputText value="#{location.country}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            Zip code:
            &lt;h:inputText value="#{location.zip}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;h:commandButton/&gt;
        &lt;/div&gt;
    <emphasis role="bold">&lt;/s:validateAll&gt;</emphasis>
&lt;/h:form&gt;</programlisting>

    <para>Going even further, and adding <productname>Ajax4JSF</productname>
    to the loop will bring client side validation with just a couple of
    additional JSF tags, again without validation definition
    duplication.</para>

    <para>Check the <ulink url="http://www.jboss.com/products/seam">JBoss
    Seam</ulink> documentation for more information.</para>
  </section>

  <section>
    <title>Validation informations</title>

    <para>As a validation information carrier, hibernate provide an array of
    <classname>InvalidValue</classname>. Each <literal>InvalidValue</literal>
    has a buch of methods describing the individual issues.</para>

    <para><methodname>getBeanClass()</methodname> retrieves the failing bean
    type</para>

    <para><methodname>getBean()</methodname>retrieves the failing instance (if
    any ie not when using
    <methodname>getPotentianInvalidValues()</methodname>)</para>

    <para><methodname>getValue()</methodname> retrieves the failing
    value</para>

    <para><methodname>getMessage()</methodname> retrieves the proper
    internationalized error message</para>

    <para><methodname>getRootBean()</methodname> retrieves the root bean
    instance generating the issue (useful in conjunction with
    <literal>@Valid</literal>), is null if getPotentianInvalidValues() is
    used.</para>

    <para><literal>getPropertyPath()</literal> retrieves the dotted path of
    the failing property starting from the root bean</para>
  </section>
</chapter>