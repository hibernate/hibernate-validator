# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-11-14 10:37+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: usingvalidator.xml:24
#, no-c-format
msgid "Validation step by step"
msgstr ""

#. Tag: para
#: usingvalidator.xml:26
#, no-c-format
msgid "In this chapter we will see in more detail how to use Hibernate Validator to validate constraints for a given entity model. We will also learn which default constraints the Bean Validation specification provides and which additional constraints are only provided by Hibernate Validator. Let's start with how to add constraints to an entity."
msgstr ""

#. Tag: title
#: usingvalidator.xml:33
#, no-c-format
msgid "Defining constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:35
#, no-c-format
msgid "Constraints in Bean Validation are expressed via Java annotations. In this section we show how to annotate an object model with these annotations. We have to differentiate between three different type of constraint annotations - field-, property-, and class-level annotations."
msgstr ""

#. Tag: para
#: usingvalidator.xml:42
#, no-c-format
msgid "Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Bean Validation can be placed at class level. The <classname>java.lang.annotation.Target</classname> annotation in the constraint annotation itself determines on which elements a constraint can be placed. See <xref linkend=\"validator-customconstraints\"/> for more information."
msgstr ""

#. Tag: title
#: usingvalidator.xml:51
#, no-c-format
msgid "Field-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:53
#, no-c-format
msgid "Constraints can be expressed by annotating a field of a class. <xref linkend=\"example-field-level\"/> shows a field level configuration example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:58
#, no-c-format
msgid "Field level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:60
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @AssertTrue\n"
      "    private boolean isRegistered;\n"
      "\n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:63
#, no-c-format
msgid "When using field level constraints field access strategy is used to access the value to be validated. This means the bean validation provider directly accesses the instance variable and does not invoke the property accessor method also if such a method exists."
msgstr ""

#. Tag: para
#: usingvalidator.xml:69
#, no-c-format
msgid "The access type (private, protected or public) does not matter."
msgstr ""

#. Tag: para
#: usingvalidator.xml:74
#, no-c-format
msgid "Static fields and properties cannot be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:78
#, no-c-format
msgid "When validating byte code enhanced objects property level constraints should be used, because the byte code enhancing library won't be able to determine a field access via reflection."
msgstr ""

#. Tag: title
#: usingvalidator.xml:85
#, no-c-format
msgid "Property-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:87
#, no-c-format
msgid "If your model class adheres to the <ulink type=\"\" url=\"http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp\">JavaBeans</ulink> standard, it is also possible to annotate the properties of a bean class instead of its fields. <xref linkend=\"example-property-level\"/> uses the same entity as in <xref linkend=\"example-field-level\"/>, however, property level constraints are used."
msgstr ""

#. Tag: para
#: usingvalidator.xml:93
#, no-c-format
msgid "The property's getter method has to be annotated, not its setter."
msgstr ""

#. Tag: title
#: usingvalidator.xml:98
#, no-c-format
msgid "Property level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:100
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.AssertTrue;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    private String manufacturer;\n"
      "\n"
      "    private boolean isRegistered;\n"
      "      \n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "\n"
      "    @NotNull\n"
      "    public String getManufacturer() {\n"
      "        return manufacturer;\n"
      "    }\n"
      "\n"
      "    public void setManufacturer(String manufacturer) {\n"
      "        this.manufacturer = manufacturer;\n"
      "    }\n"
      "\n"
      "    @AssertTrue\n"
      "    public boolean isRegistered() {\n"
      "        return isRegistered;\n"
      "    }\n"
      "\n"
      "    public void setRegistered(boolean isRegistered) {\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:103
#, no-c-format
msgid "When using property level constraints property access strategy is used to access the value to be validated. This means the bean validation provider accesses the state via the property accessor method. One advantage of annotating properties instead of fields is that the constraints become part of the constrained type's API that way and users are aware of the existing constraints without having to examine the type's implementation."
msgstr ""

#. Tag: para
#: usingvalidator.xml:112
#, no-c-format
msgid "It is recommended to stick either to field <emphasis>or</emphasis> property annotations within one class. It is not recommended to annotate a field <emphasis>and</emphasis> the accompanying getter method as this would cause the field to be validated twice."
msgstr ""

#. Tag: title
#: usingvalidator.xml:121
#, no-c-format
msgid "Class-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:124
#, no-c-format
msgid "Last but not least, a constraint can also be placed on class level. When a constraint annotation is placed on this level the class instance itself passed to the <classname>ConstraintValidator</classname>. Class level constraints are useful if it is necessary to inspect more than a single property of the class to validate it or if a correlation between different state variables has to be evaluated. In <xref linkend=\"example-class-level\"/> we add the property <property>passengers</property> to the class <classname>Car</classname>. We also add the constraint <classname>PassengerCount</classname> on the class level. We will later see how we can actually create this custom constraint (see <xref linkend=\"validator-customconstraints\"/>). For now it is enough to know that <classname>PassengerCount</classname> will ensure that there cannot be more passengers in a car than there are seats."
msgstr ""

#. Tag: title
#: usingvalidator.xml:140
#, no-c-format
msgid "Class level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:142
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.Min;\n"
      "import javax.validation.constraints.NotNull;\n"
      "import javax.validation.constraints.Size;\n"
      "\n"
      "@PassengerCount\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "    \n"
      "    private List&lt;Person&gt; passengers;\n"
      "    \n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:147
#, no-c-format
msgid "Constraint inheritance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:149
#, no-c-format
msgid "When validating an object that implements an interface or extends another class, all constraint annotations on the implemented interface and parent class apply in the same manner as the constraints specified on the validated object itself. To make things clearer let's have a look at the following example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:156
#, no-c-format
msgid "Constraint inheritance using RentalCar"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:158
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class RentalCar extends Car {\n"
      "\n"
      "    private String rentalStation;\n"
      "    \n"
      "    public RentalCar(String manufacturer, String rentalStation) {\n"
      "        super(manufacturer);\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "    \n"
      "    @NotNull\n"
      "    public String getRentalStation() {\n"
      "        return rentalStation;\n"
      "    }\n"
      "\n"
      "    public void setRentalStation(String rentalStation) {\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:161
#, no-c-format
msgid "Our well-known class <classname>Car</classname> is now extended by <classname>RentalCar</classname> with the additional property <property>rentalStation</property>. If an instance of <classname>RentalCar</classname> is validated, not only the <classname>@NotNull</classname> constraint on <property>rentalStation</property> is validated, but also the constraint on <property>manufacturer</property> from the parent class."
msgstr ""

#. Tag: para
#: usingvalidator.xml:169
#, no-c-format
msgid "The same would hold true, if <classname>Car</classname> were an interface implemented by <classname>RentalCar</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:172
#, no-c-format
msgid "Constraint annotations are aggregated if methods are overridden. If <classname>RentalCar</classname> would override the <methodname>getManufacturer()</methodname> method from <classname>Car</classname> any constraints annotated at the overriding method would be evaluated in addition to the <classname>@NotNull</classname> constraint from the super-class."
msgstr ""

#. Tag: title
#: usingvalidator.xml:181
#, no-c-format
msgid "Object graphs"
msgstr ""

#. Tag: para
#: usingvalidator.xml:183
#, no-c-format
msgid "The Bean Validation API does not only allow to validate single class instances but also complete object graphs. To do so, just annotate a field or property representing a reference to another object with <classname>@Valid</classname>. If the parent object is validated, all referenced objects annotated with <classname>@Valid</classname> will be validated as well (as will be their children etc.). See <xref linkend=\"example-car-with-driver\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:192
#, no-c-format
msgid "Class Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:194
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    @NotNull\n"
      "    private String name;\n"
      "    \n"
      "    public Person(String name) {\n"
      "        super();\n"
      "        this.name = name;\n"
      "    }\n"
      "\n"
      "    public String getName() {\n"
      "        return name;\n"
      "    }\n"
      "\n"
      "    public void setName(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:198
#, no-c-format
msgid "Adding a driver to the car"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:200
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private Person driver;\n"
      "    \n"
      "    public Car(Person driver) {\n"
      "        this.driver = driver;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:203
#, no-c-format
msgid "If an instance of <classname>Car</classname> is validated, the referenced <classname>Person</classname> object will be validated as well, as the <property>driver</property> field is annotated with <classname>@Valid</classname>. Therefore the validation of a <classname>Car</classname> will fail if the <property>name</property> field of the referenced <classname>Person</classname> instance is <code>null</code>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:211
#, no-c-format
msgid "Object graph validation also works for collection-typed fields. That means any attributes that"
msgstr ""

#. Tag: para
#: usingvalidator.xml:216
#, no-c-format
msgid "are arrays"
msgstr ""

#. Tag: para
#: usingvalidator.xml:220
#, no-c-format
msgid "implement <classname>java.lang.Iterable</classname> (especially <classname>Collection</classname>, <classname>List</classname> and <classname>Set</classname>)"
msgstr ""

#. Tag: para
#: usingvalidator.xml:226
#, no-c-format
msgid "implement <classname>java.util.Map</classname>"
msgstr ""

#. Tag: para
#: usingvalidator.xml:230
#, no-c-format
msgid "can be annotated with <classname>@Valid</classname>, which will cause each contained element to be validated, when the parent object is validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:235
#, no-c-format
msgid "Car with a list of passengers"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:237
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import java.util.ArrayList;\n"
      "import java.util.List;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();\n"
      "\n"
      "    public Car(List&lt;Person&gt; passengers) {\n"
      "        this.passengers = passengers;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:240
#, no-c-format
msgid "If a <classname>Car</classname> instance is validated, a <classname>ConstraintValidation</classname> will be created, if any of the <classname>Person</classname> objects contained in the <property>passengers</property> list has a <code>null</code> name."
msgstr ""

#. Tag: para
#: usingvalidator.xml:244
#, no-c-format
msgid "<classname>null</classname> values are getting ignored when validating object graphs."
msgstr ""

#. Tag: title
#: usingvalidator.xml:251
#, no-c-format
msgid "Validating constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:253
#, no-c-format
msgid "The <classname>Validator</classname> interface is the main entry point to Bean Validation. In <xref linkend=\"section-validator-instance\"/> we will first show how to obtain an <classname>Validator</classname> instance. Afterwards we will learn how to use the different methods of the <classname>Validator</classname> interface."
msgstr ""

#. Tag: title
#: usingvalidator.xml:260
#, no-c-format
msgid "Obtaining a <classname>Validator</classname> instance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:262
#, no-c-format
msgid "The first step towards validating an entity instance is to get hold of a <classname>Validator</classname> instance. The road to this instance leads via the <classname>Validation</classname> class and a <classname>ValidatorFactory</classname>. The easiest way is to use the static <methodname>Validation.buildDefaultValidatorFactory()</methodname> method:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:271
#, no-c-format
msgid "Validation.buildDefaultValidatorFactory()"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:273
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();"
msgstr ""

#. Tag: para
#: usingvalidator.xml:276
#, no-c-format
msgid "For other ways of obtaining a Validator instance see <xref linkend=\"validator-bootstrapping\"/>. For now we just want to see how we can use the <classname>Validator</classname> instance to validate entity instances."
msgstr ""

#. Tag: title
#: usingvalidator.xml:283
#, no-c-format
msgid "Validator methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:285
#, no-c-format
msgid "The <classname>Validator</classname> interface contains three methods that can be used to either validate entire entities or just a single properties of the entity."
msgstr ""

#. Tag: para
#: usingvalidator.xml:289
#, no-c-format
msgid "All three methods return a <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty, if the validation succeeds. Otherwise a <classname>ConstraintViolation</classname> instance is added for each violated constraint."
msgstr ""

#. Tag: para
#: usingvalidator.xml:295
#, no-c-format
msgid "All the validation methods have a var-args parameter which can be used to specify, which validation groups shall be considered when performing the validation. If the parameter is not specified the default validation group (<classname>javax.validation.groups.Default</classname>) will be used. We will go into more detail on the topic of validation groups in"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:304
#, no-c-format
msgid "validate"
msgstr ""

#. Tag: para
#: usingvalidator.xml:306
#, no-c-format
msgid "Use the <methodname>validate()</methodname> method to perform validation of all constraints of a given entity instance (see <xref linkend=\"example-validator-validate\"/> )."
msgstr ""

#. Tag: title
#: usingvalidator.xml:311
#, no-c-format
msgid "Usage of <methodname>Validator.validate()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:314
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:319
#, no-c-format
msgid "validateProperty"
msgstr ""

#. Tag: para
#: usingvalidator.xml:321
#, no-c-format
msgid "With help of the <methodname>validateProperty()</methodname> a single named property of a given object can be validated. The property name is the JavaBeans property name."
msgstr ""

#. Tag: title
#: usingvalidator.xml:326
#, no-c-format
msgid "Usage of <methodname>Validator.validateProperty()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:329
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, \"manufacturer\");\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:332
#, no-c-format
msgid "<methodname>Validator.validateProperty</methodname> is for example used in the integration of Bean Validation into JSF 2 (see <xref linkend=\"section-presentation-layer\"/>)."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:338
#, no-c-format
msgid "validateValue"
msgstr ""

#. Tag: para
#: usingvalidator.xml:340
#, no-c-format
msgid "Using the <methodname>validateValue() </methodname>method you can check, whether a single property of a given class can be validated successfully, if the property had the specified value:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:345
#, no-c-format
msgid "Usage of <methodname>Validator.validateValue()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:348
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, \"manufacturer\", null);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:352
#, no-c-format
msgid "<classname>@Valid</classname> is not honored by <methodname>validateProperty()</methodname> or <methodname>validateValue()</methodname>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:360
#, no-c-format
msgid "<classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:362
#, no-c-format
msgid "Now it is time to have a closer look at what a <classname>ConstraintViolation</classname>. Using the different methods of <classname>ConstraintViolation</classname> a lot of useful information about the cause of the validation failure can be determined. <xref linkend=\"table-constraint-violation\"/> gives an overview of these methods:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:370
#, no-c-format
msgid "The various <classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:376
#, no-c-format
msgid "Method"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:378
#, no-c-format
msgid "Usage"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:380
#, no-c-format
msgid "Example (referring to <xref linkend=\"example-validator-validate\"/>)"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:387
#, no-c-format
msgid "getMessage()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:389
#, no-c-format
msgid "The interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:391
#, no-c-format
msgid "may not be null"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:395
#, no-c-format
msgid "getMessageTemplate()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:397
#, no-c-format
msgid "The non-interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:399
#, no-c-format
msgid "{javax.validation.constraints.NotNull.message}"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:403
#, no-c-format
msgid "getRootBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:405
#, no-c-format
msgid "The root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:407 usingvalidator.xml:425
#, no-c-format
msgid "<entry>car</entry>"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:411
#, no-c-format
msgid "getRootBeanClass()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:413
#, no-c-format
msgid "The class of the root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:415
#, no-c-format
msgid "Car.class"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:419
#, no-c-format
msgid "getLeafBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:421
#, no-c-format
msgid "If a bean constraint, the bean instance the constraint is applied on. If a property constraint, the bean instance hosting the property the constraint is applied on."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:429
#, no-c-format
msgid "getPropertyPath()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:431
#, no-c-format
msgid "The property path to the value from root bean."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:437
#, no-c-format
msgid "getInvalidValue()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:439
#, no-c-format
msgid "The value failing to pass the constraint."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:441
#, no-c-format
msgid "passengers"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:445
#, no-c-format
msgid "getConstraintDescriptor()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:447
#, no-c-format
msgid "Constraint metadata reported to fail."
msgstr ""

#. Tag: title
#: usingvalidator.xml:457
#, no-c-format
msgid "Message interpolation"
msgstr ""

#. Tag: para
#: usingvalidator.xml:459
#, no-c-format
msgid "As we will see in <xref linkend=\"validator-customconstraints\"/> each constraint definition must define a default message descriptor. This message can be overridden at declaration time using the <methodname>message</methodname> attribute of the constraint. You can see this in <xref linkend=\"example-driver\"/>. This message descriptors get interpolated when a constraint validation fails using the configured <classname>MessageInterpolator</classname>. The interpolator will try to resolve any message parameters, meaning string literals enclosed in braces. In order to resolve these parameters Hibernate Validator's default <classname>MessageInterpolator</classname> first recursively resolves parameters against a custom <classname>ResourceBundle</classname> called <filename>ValidationMessages.properties</filename> at the root of the classpath (It is up to you to create this file). If no further replacements are possible against the custom bundle the default <classname>ResourceBundle</classname> under <filename>/org/hibernate/validator/ValidationMessages.properties</filename> gets evaluated. If a replacement occurs against the default bundle the algorithm looks again at the custom bundle (and so on). Once no further replacements against these two resource bundles are possible remaining parameters are getting resolved against the attributes of the constraint to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:482
#, no-c-format
msgid "Since the braces { and } have special meaning in the messages they need to be escaped if they are used literally. The following The following rules apply:"
msgstr ""

#. Tag: para
#: usingvalidator.xml:486
#, no-c-format
msgid "\\{ is considered as the literal {"
msgstr ""

#. Tag: para
#: usingvalidator.xml:490
#, no-c-format
msgid "\\} is considered as the literal }"
msgstr ""

#. Tag: para
#: usingvalidator.xml:494
#, no-c-format
msgid "\\\\ is considered as the literal \\"
msgstr ""

#. Tag: para
#: usingvalidator.xml:498
#, no-c-format
msgid "If the default message interpolator does not fit your requirements it is possible to plug a custom <classname>MessageInterpolator</classname> when the <classname>ValidatorFactory</classname> gets created. This can be seen in <xref linkend=\"validator-bootstrapping\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:507
#, no-c-format
msgid "Validating groups"
msgstr ""

#. Tag: para
#: usingvalidator.xml:509
#, no-c-format
msgid "Groups allow you to restrict the set of constraints applied during validation. This makes for example wizard like validation possible where in each step only a specified subset of constraints get validated. The groups targeted are passed as var-args parameters to <methodname>validate</methodname>, <methodname>validateProperty</methodname> and <methodname>validateValue</methodname>. Let's have a look at an extended <classname>Car</classname> with <classname>Driver</classname> example. First we have the class <classname>Person</classname> (<xref linkend=\"example-person\"/>) which has a <classname>@NotNull </classname>constraint on <property>name</property>. Since no group is specified for this annotation its default group is <classname>javax.validation.groups.Default</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:524
#, no-c-format
msgid "When more than one group is requested, the order in which the groups are evaluated is not deterministic. If no group is specified the default group <classname>javax.validation.groups.Default</classname> is assumed."
msgstr ""

#. Tag: title
#: usingvalidator.xml:531
#, no-c-format
msgid "Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:533
#, no-c-format
msgid ""
      "public class Person {\n"
      "    @NotNull\n"
      "    private String name;\n"
      "\n"
      "    public Person(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "    // getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:536
#, no-c-format
msgid "Next we have the class <classname>Driver</classname> (<xref linkend=\"example-driver\"/>) extending <classname>Person</classname>. Here we are adding the properties <property>age</property> and <property>hasDrivingLicense</property>. In order to drive you must be at least 18 (<classname>@Min(18)</classname>) and you must have a driving license (<classname>@AssertTrue</classname>). Both constraints defined on these properties belong to the group <classname>DriverChecks</classname>. As you can see in <xref linkend=\"example-group-interfaces\"/> the group <classname>DriverChecks</classname> is just a simple tagging interface. Using interfaces makes the usage of groups type safe and allows for easy refactoring. It also means that groups can inherit from each other via class inheritance."
msgstr ""

#. Tag: title
#: usingvalidator.xml:550
#, no-c-format
msgid "Driver"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:552
#, no-c-format
msgid ""
      "public class Driver extends Person {\n"
      "    @Min(value = 18, message = \"You have to be 18 to drive a car\", groups = DriverChecks.class)\n"
      "    public int age;\n"
      "\n"
      "    @AssertTrue(message = \"You first have to pass the driving test\", groups = DriverChecks.class)\n"
      "    public boolean hasDrivingLicense;\n"
      "\n"
      "    public Driver(String name) {\n"
      "        super( name );\n"
      "    }\n"
      "\n"
      "    public void passedDrivingTest(boolean b) {\n"
      "        hasDrivingLicense = b;\n"
      "    }\n"
      "\n"
      "    public int getAge() {\n"
      "        return age;\n"
      "    }\n"
      "\n"
      "    public void setAge(int age) {\n"
      "        this.age = age;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:556
#, no-c-format
msgid "Group interfaces"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:558
#, no-c-format
msgid ""
      "public interface DriverChecks {\n"
      "}\n"
      "\n"
      "public interface CarChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:561
#, no-c-format
msgid "Last but not least we add the property <property>passedVehicleInspection</property> to the <classname>Car</classname> class (<xref linkend=\"example-car\"/>) indicating whether a car passed the road worthy tests."
msgstr ""

#. Tag: title
#: usingvalidator.xml:567
#, no-c-format
msgid "<title>Car</title>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:569
#, no-c-format
msgid ""
      "public class Car {\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "\n"
      "    @AssertTrue(message = \"The car has to pass the vehicle inspection first\", groups = CarChecks.class)\n"
      "    private boolean passedVehicleInspection;\n"
      "\n"
      "    @Valid\n"
      "    private Driver driver;\n"
      "\n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:572
#, no-c-format
msgid "Overall three different groups are used in our example. <property>Person.name</property>, <property>Car.manufacturer</property>, <property>Car.licensePlate</property> and <property>Car.seatCount</property> all belong to the <classname>Default</classname> group. <property>Driver.age</property> and <property>Driver.hasDrivingLicense</property> belong to <classname>DriverChecks</classname> and last but not least <property>Car.passedVehicleInspection</property> belongs to the group <classname>CarChecks</classname>. <xref linkend=\"example-drive-away\"/> shows how passing different group combinations to the <methodname>Validator.validate</methodname> method result in different validation results."
msgstr ""

#. Tag: title
#: usingvalidator.xml:586
#, no-c-format
msgid "Drive away"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:588
#, no-c-format
msgid ""
      "public class GroupTest {\n"
      "\n"
      "    private static Validator validator;\n"
      "\n"
      "    @BeforeClass\n"
      "    public static void setUp() {\n"
      "        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "        validator = factory.getValidator();\n"
      "    }\n"
      "\n"
      "    @Test\n"
      "    public void driveAway() {\n"
      "        // create a car and check that everything is ok with it.\n"
      "        Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );\n"
      "        assertEquals( 0, constraintViolations.size() );\n"
      "\n"
      "        // but has it passed the vehicle inspection?\n"
      "        constraintViolations = validator.validate( car, CarChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals(\"The car has to pass the vehicle inspection first\", constraintViolations.iterator().next().getMessage());\n"
      "\n"
      "        // let's go to the vehicle inspection\n"
      "        car.setPassedVehicleInspection( true );\n"
      "        assertEquals( 0, validator.validate( car ).size() );\n"
      "\n"
      "        // now let's add a driver. He is 18, but has not passed the driving test yet\n"
      "        Driver john = new Driver( \"John Doe\" );\n"
      "        john.setAge( 18 );\n"
      "        car.setDriver( john );\n"
      "        constraintViolations = validator.validate( car, DriverChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals( \"You first have to pass the driving test\", constraintViolations.iterator().next().getMessage() );\n"
      "\n"
      "        // ok, John passes the test\n"
      "        john.passedDrivingTest( true );\n"
      "        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );\n"
      "\n"
      "        // just checking that everything is in order now\n"
      "        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:591
#, no-c-format
msgid "First we create a car and validate it using no explicit group. There are no validation errors, even though the property <property>passedVehicleInspection</property> is per default <constant>false</constant>. However, the constraint defined on this property does not belong to the default group. Next we just validate the <classname>CarChecks</classname> group which will fail until we make sure that the car passes the vehicle inspection. When we then add a driver to the car and validate against <classname>DriverChecks</classname> we get again a constraint violation due to the fact that the driver has not yet passed the driving test. Only after setting <property>passedDrivingTest</property> to true the validation against <classname>DriverChecks</classname> will pass."
msgstr ""

#. Tag: para
#: usingvalidator.xml:604
#, no-c-format
msgid "Last but not least, we show that all constraints are passing by validating against all defined groups."
msgstr ""

#. Tag: title
#: usingvalidator.xml:608
#, no-c-format
msgid "Group sequences"
msgstr ""

#. Tag: para
#: usingvalidator.xml:610
#, no-c-format
msgid "By default, constraints are evaluated in no particular order and this regardless of which groups they belong to. In some situations, however, it is useful to control the order of the constraint evaluation. In our example from <xref linkend=\"validator-usingvalidator-validationgroups\"/> we could for example require that first all default car constraints are passing before we check the road worthiness of the car. Finally before we drive away we check the actual driver constraints. In order to implement such an order one would define a new interface and annotate it with <classname>@GroupSequence</classname> defining the order in which the groups have to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:623
#, no-c-format
msgid "If at least one constraints fails in a sequenced group none of the constraints of the following groups in the sequence get validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:629
#, no-c-format
msgid "Interface with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:631
#, no-c-format
msgid ""
      "@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})\n"
      "public interface OrderedChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:635
#, no-c-format
msgid "Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency either directly or indirectly, either through cascaded sequence definition or group inheritance. If a group containing such a circularity is evaluated, a <classname>GroupDefinitionException</classname> is raised."
msgstr ""

#. Tag: para
#: usingvalidator.xml:639
#, no-c-format
msgid "The usage of the new sequence could then look like in <xref linkend=\"example-group-sequence\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:644
#, no-c-format
msgid "Usage of a group sequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:646
#, no-c-format
msgid ""
      "@Test\n"
      "public void testOrderedChecks() {\n"
      "    Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "    car.setPassedVehicleInspection( true );\n"
      "\n"
      "    Driver john = new Driver( \"John Doe\" );\n"
      "    john.setAge( 18 );\n"
      "    john.passedDrivingTest( true );\n"
      "    car.setDriver( john );\n"
      "\n"
      "    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:651
#, no-c-format
msgid "Redefining the default group sequence of a class"
msgstr ""

#. Tag: title
#: usingvalidator.xml:654
#, no-c-format
msgid "@GroupSequence"
msgstr ""

#. Tag: para
#: usingvalidator.xml:656
#, no-c-format
msgid "The <classname>@GroupSequence</classname> annotation also fulfills a second purpose. It allows you to redefine what the <constant>Default</constant> group means for a given class. To redefine <classname>Default</classname> for a given class, add a <classname>@GroupSequence</classname> annotation to the class. The defined groups in the annotation express the sequence of groups that substitute <classname>Default</classname> for this class. <xref linkend=\"example-rental-car\"/> introduces a new class <classname>RentalCar</classname> with a redefined default group. With this definition the check for all three groups can be rewritten as seen in <xref linkend=\"example-testOrderedChecksWithRedefinedDefault\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:670
#, no-c-format
msgid "RentalCar with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:672
#, no-c-format
msgid ""
      "@GroupSequence({ RentalCar.class, CarChecks.class, DriverChecks.class })\n"
      "public class RentalCar extends Car {\n"
      "    private boolean rented;    \n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "   public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(booelan rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:676
#, no-c-format
msgid "testOrderedChecksWithRedefinedDefault"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:678
#, no-c-format
msgid ""
      "@Test\n"
      "public void testOrderedChecksWithRedefinedDefault() {\n"
      "    RentalCar rentalCar = new RentalCar( \"Morris\", \"DD-AB-123\", 2 );\n"
      "    rentalCar.setPassedVehicleInspection( true );\n"
      "\n"
      "    Driver john = new Driver( \"John Doe\" );\n"
      "    john.setAge( 18 );\n"
      "    john.passedDrivingTest( true );\n"
      "    rentalCar.setDriver( john );\n"
      "\n"
      "    assertEquals( 0, validator.validate( rentalCar, Default.class ).size() );\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:682
#, no-c-format
msgid "Due to the fact that there cannot be a cyclic dependency in the group and group sequence definitions one cannot just add <classname>Default</classname> to the sequence redefining <classname>Default</classname> for a class. Instead the class itself should be added!"
msgstr ""

#. Tag: title
#: usingvalidator.xml:691
#, no-c-format
msgid "@GroupSequenceProvider"
msgstr ""

#. Tag: para
#: usingvalidator.xml:693
#, no-c-format
msgid "The <classname>@javax.validation.GroupSequence</classname> annotation is a standardized Bean Validation annotation. As seen in the previous section it allows you to statically redefine the default group sequence for a class. Hibernate Validator also offers a custom, non standardized annotation - <classname>org.hibernate.validator.group.GroupSequenceProvider </classname>- which allows for dynamic redefinition of the default group sequence. Using the rental car scenario again, one could dynamically add the driver checks depending on whether the car is rented or not. <xref linkend=\"example-rental-car-group-sequence-provider\"/> and <xref linkend=\"example-group-sequence-provider-implementation\"/> show how this use-case would be implemented."
msgstr ""

#. Tag: title
#: usingvalidator.xml:708
#, no-c-format
msgid "RentalCar with @GroupSequenceProvider"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:710
#, no-c-format
msgid ""
      "@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)\n"
      "public class RentalCar extends Car {\n"
      "    private boolean rented;    \n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "   public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(boolean rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:714
#, no-c-format
msgid "DefaultGroupSequenceProvider implementation"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:716
#, no-c-format
msgid ""
      "public class RentalCarGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {\n"
      "    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {\n"
      "        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();\n"
      "        defaultGroupSequence.add( RentalCar.class, CarChecks.class );\n"
      "\n"
      "        if ( car != null &amp;&amp; car.isRented() ) {\n"
      "            defaultGroupSequence.add( DriverChecks.class );\n"
      "        }\n"
      "\n"
      "        return defaultGroupSequence;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:723
#, no-c-format
msgid "Built-in constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:725
#, no-c-format
msgid "Hibernate Validator comprises a basic set of commonly used constraints. These are foremost the constraints defined by the Bean Validation specification (see <xref linkend=\"table-spec-constraints\"/>). Additionally, Hibernate Validator provides useful custom constraints (see <xref linkend=\"table-custom-constraints\"/>)."
msgstr ""

#. Tag: title
#: usingvalidator.xml:732 usingvalidator.xml:751
#, no-c-format
msgid "Bean Validation constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:734
#, no-c-format
msgid "shows purpose and supported data types of all constraints specified in the Bean Validation API. All these constraints apply to the field/property level, there are no class-level constraints defined in the Bean Validation specification. If you are using the Hibernate object-relational mapper, some of the constraints are taken into account when creating the DDL for your model (see column \"Hibernate metadata impact\")."
msgstr ""

#. Tag: para
#: usingvalidator.xml:743
#, no-c-format
msgid "Hibernate Validator allows some constraints to be applied to more data types than required by the Bean Validation specification (e.g. @Max can be applied to <classname>Strings</classname>). Relying on this feature can impact portability of your application between Bean Validation providers."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:764 usingvalidator.xml:1019
#, no-c-format
msgid "Annotation"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:766 usingvalidator.xml:1021
#, no-c-format
msgid "Supported data types"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:768 usingvalidator.xml:1023
#, no-c-format
msgid "<entry>Use</entry>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:770 usingvalidator.xml:1025
#, no-c-format
msgid "Hibernate metadata impact"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:776
#, no-c-format
msgid "@AssertFalse"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:778 usingvalidator.xml:790
#, no-c-format
msgid "<classname>Boolean</classname>, <classname>boolean</classname>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:781
#, no-c-format
msgid "Checks that the annotated element is <constant>false</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:784 usingvalidator.xml:796 usingvalidator.xml:815 usingvalidator.xml:834 usingvalidator.xml:869 usingvalidator.xml:927 usingvalidator.xml:943 usingvalidator.xml:955 usingvalidator.xml:981 usingvalidator.xml:1041 usingvalidator.xml:1052 usingvalidator.xml:1077 usingvalidator.xml:1090 usingvalidator.xml:1106 usingvalidator.xml:1123 usingvalidator.xml:1142 usingvalidator.xml:1160
#, no-c-format
msgid "none"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:788
#, no-c-format
msgid "@AssertTrue"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:793
#, no-c-format
msgid "Checks that the annotated element is <constant>true</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:800
#, no-c-format
msgid "@DecimalMax"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:802 usingvalidator.xml:821 usingvalidator.xml:840
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>String</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: any sub-type of <classname>Number</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:810
#, no-c-format
msgid "The annotated element must be a number whose value must be lower or equal to the specified maximum. The parameter value is the string representation of the max value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:819
#, no-c-format
msgid "@DecimalMin"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:829
#, no-c-format
msgid "The annotated element must be a number whose value must be higher or equal to the specified minimum. The parameter value is the string representation of the min value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:838
#, no-c-format
msgid "@Digits(integer=, fraction=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:848
#, no-c-format
msgid "Checks whether the annoted value is a number having up to <literal>integer</literal> digits and <literal>fraction</literal> fractional digits."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:852
#, no-c-format
msgid "Define column precision and scale."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:856
#, no-c-format
msgid "@Future"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:858 usingvalidator.xml:933
#, no-c-format
msgid "<classname>java.util.Date</classname>, <classname>java.util.Calendar</classname>; Additionally supported by HV, if the <ulink url=\"http://joda-time.sourceforge.net/\">Joda Time</ulink> date/time API is on the class path: any implementations of <classname>ReadablePartial</classname> and <classname>ReadableInstant</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:866
#, no-c-format
msgid "Checks whether the annotated date is in the future."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:873
#, no-c-format
msgid "@Max"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:875 usingvalidator.xml:893
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: <classname>String</classname> (the numeric value represented by a String is evaluated), any sub-type of <classname>Number</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:884
#, no-c-format
msgid "Checks whether the annotated value is less than or equal to the specified maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:887 usingvalidator.xml:905
#, no-c-format
msgid "Add a check constraint on the column."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:891
#, no-c-format
msgid "@Min"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:902
#, no-c-format
msgid "Checks whether the annotated value is higher than or equal to the specified minimum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:909
#, no-c-format
msgid "@NotNull"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:911 usingvalidator.xml:922 usingvalidator.xml:1129
#, no-c-format
msgid "Any type"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:913
#, no-c-format
msgid "Checks that the annotated value is not <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:916
#, no-c-format
msgid "Column(s) are not null."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:920
#, no-c-format
msgid "@Null"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:924
#, no-c-format
msgid "Checks that the annotated value is <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:931
#, no-c-format
msgid "@Past"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:941
#, no-c-format
msgid "Checks whether the annotated date is in the past."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:947
#, no-c-format
msgid "@Pattern(regex=, flag=)"
msgstr ""

#. Tag: classname
#: usingvalidator.xml:949 usingvalidator.xml:1033 usingvalidator.xml:1047 usingvalidator.xml:1058 usingvalidator.xml:1070 usingvalidator.xml:1148
#, no-c-format
msgid "String"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:951
#, no-c-format
msgid "Checks if the annotated string matches the regular expression <parameter>regex</parameter> considering the given flag <parameter>match</parameter>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:959
#, no-c-format
msgid "@Size(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:961
#, no-c-format
msgid "<classname>String</classname>, <classname>Collection</classname>, <classname>Map</classname> and <classname>arrays</classname>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:965
#, no-c-format
msgid "Checks if the annotated element's size is between min and max (inclusive)."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:968 usingvalidator.xml:1064
#, no-c-format
msgid "Column length will be set to max."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:972
#, no-c-format
msgid "@Valid"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:974
#, no-c-format
msgid "Any non-primitive type"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:976
#, no-c-format
msgid "Performs validation recursively on the associated object. If the object is a collection or an array, the elements are validated recursively. If the object is a map, the value elements are validated recursively."
msgstr ""

#. Tag: para
#: usingvalidator.xml:988
#, no-c-format
msgid "On top of the parameters indicated in <xref linkend=\"table-spec-constraints\"/> each constraint supports the parameters <parameter>message</parameter>, <parameter>groups</parameter> and <parameter>payload</parameter>. This is a requirement of the Bean Validation specification."
msgstr ""

#. Tag: title
#: usingvalidator.xml:997
#, no-c-format
msgid "Additional constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:999
#, no-c-format
msgid "In addition to the constraints defined by the Bean Validation API Hibernate Validator provides several useful custom constraints which are listed in <xref linkend=\"table-custom-constraints\"/>. With one exception also these constraints apply to the field/property level, only @ScriptAssert is a class-level constraint."
msgstr ""

#. Tag: title
#: usingvalidator.xml:1006
#, no-c-format
msgid "Custom constraints provided by Hibernate Validator"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1031
#, no-c-format
msgid "@CreditCardNumber"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1035
#, no-c-format
msgid "Checks that the annotated string passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also <ulink url=\"http://www.merriampark.com/anatomycc.htm\">Anatomy of Credit Card Numbers</ulink>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1045
#, no-c-format
msgid "@Email"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1049
#, no-c-format
msgid "Checks whether the specified string is a valid email address."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1056
#, no-c-format
msgid "@Length(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1060
#, no-c-format
msgid "Validates that the annotated string is between <parameter>min</parameter> and <parameter>max</parameter> included."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1068
#, no-c-format
msgid "@NotBlank"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1072
#, no-c-format
msgid "Checks that the annotated string is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on strings and that trailing whitespaces are ignored."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1081
#, no-c-format
msgid "@NotEmpty"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1083
#, no-c-format
msgid "<classname>String</classname>, <classname>Collection</classname>, <classname>Map</classname> and arrays"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1087
#, no-c-format
msgid "Checks whether the annotated element is not <constant>null</constant> nor empty."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1094
#, no-c-format
msgid "@Range(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1096
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>String</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1103
#, no-c-format
msgid "Checks whether the annotated value lies between (inclusive) the specified minimum and maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1110
#, no-c-format
msgid "@SafeHtml(whitelistType=, additionalTags=)"
msgstr ""

#. Tag: classname
#: usingvalidator.xml:1112
#, no-c-format
msgid "CharSequence"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1114
#, no-c-format
msgid "Checks whether the annotated value contains potentially malicious fragments such as <code>&lt;script/&gt;</code>. In order to use this constraint, the <ulink url=\"http://jsoup.org/\">jsoup</ulink> library must be part of the class path. With the <parameter>whitelistType</parameter> attribute predefined whitelist types can be chosen. You can also specify additional html tags for the whitelist with the <parameter>additionalTags</parameter> attribute."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1127
#, no-c-format
msgid "@ScriptAssert(lang=, script=, alias=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1131
#, no-c-format
msgid "Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 (\"Scripting for the Java<superscript>TM</superscript> Platform\") must part of the class path. This is automatically the case when running on Java 6. For older Java versions, the JSR 223 RI can be added manually to the class path.The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1146
#, no-c-format
msgid "@URL(protocol=, host=, port=, regexp=, flags=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1150
#, no-c-format
msgid "Checks if the annotated string is a valid URL according to RFC2396. If any of the optional parameters <parameter>protocol</parameter>, <parameter>host</parameter> or <parameter>port</parameter> are specified, the corresponding URL fragments must match the specified values. The optional parameters <parameter>regexp</parameter> and <parameter>flags</parameter> allow to specify an additional regular expression (including regular expression flags) which the URL must match."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1166
#, no-c-format
msgid "In some cases neither the Bean Validation constraints nor the custom constraints provided by Hibernate Validator will fulfill your requirements completely. In this case you can literally in a minute write your own constraints. We will discuss this in <xref linkend=\"validator-customconstraints\"/>."
msgstr ""

