# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-02-11 14:56+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: usingvalidator.xml:24
#, no-c-format
msgid "Validation step by step"
msgstr ""

#. Tag: para
#: usingvalidator.xml:26
#, no-c-format
msgid "In this chapter we will see in more detail how to use Hibernate Validator to validate constraints for a given entity model. We will also learn which default constraints the Bean Validation specification provides and which additional constraints are only provided by Hibernate Validator. Let's start with how to add constraints to an entity."
msgstr ""

#. Tag: title
#: usingvalidator.xml:33
#, no-c-format
msgid "Defining constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:35
#, no-c-format
msgid "Constraints in Bean Validation are expressed via Java annotations. In this section we show how to annotate an object model with these annotations. We have to differentiate between three different type of constraint annotations - field-, property-, and class-level annotations."
msgstr ""

#. Tag: para
#: usingvalidator.xml:42
#, no-c-format
msgid "Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Bean Validation can be placed at class level. The <classname>java.lang.annotation.Target</classname> annotation in the constraint annotation itself determines on which elements a constraint can be placed. See <xref linkend=\"validator-customconstraints\"/> for more information."
msgstr ""

#. Tag: title
#: usingvalidator.xml:51
#, no-c-format
msgid "Field-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:53
#, no-c-format
msgid "Constraints can be expressed by annotating a field of a class. <xref linkend=\"example-field-level\"/> shows a field level configuration example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:58
#, no-c-format
msgid "Field level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:60
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @AssertTrue\n"
      "    private boolean isRegistered;\n"
      "\n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:63
#, no-c-format
msgid "When using field level constraints field access strategy is used to access the value to be validated. This means the bean validation provider directly accesses the instance variable and does not invoke the property accessor method also if such a method exists."
msgstr ""

#. Tag: para
#: usingvalidator.xml:69
#, no-c-format
msgid "The access type (private, protected or public) does not matter."
msgstr ""

#. Tag: para
#: usingvalidator.xml:74
#, no-c-format
msgid "Static fields and properties cannot be validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:79
#, no-c-format
msgid "Property-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:81
#, no-c-format
msgid "If your model class adheres to the <ulink type=\"\" url=\"http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp\">JavaBeans</ulink> standard, it is also possible to annotate the properties of a bean class instead of its fields. <xref linkend=\"example-property-level\"/> uses the same entity as in <xref linkend=\"example-field-level\"/>, however, property level constraints are used."
msgstr ""

#. Tag: para
#: usingvalidator.xml:87
#, no-c-format
msgid "The property's getter method has to be annotated, not its setter."
msgstr ""

#. Tag: title
#: usingvalidator.xml:92
#, no-c-format
msgid "Property level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:94
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.AssertTrue;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    private String manufacturer;\n"
      "\n"
      "    private boolean isRegistered;\n"
      "      \n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "\n"
      "    @NotNull\n"
      "    public String getManufacturer() {\n"
      "        return manufacturer;\n"
      "    }\n"
      "\n"
      "    public void setManufacturer(String manufacturer) {\n"
      "        this.manufacturer = manufacturer;\n"
      "    }\n"
      "\n"
      "    @AssertTrue\n"
      "    public boolean isRegistered() {\n"
      "        return isRegistered;\n"
      "    }\n"
      "\n"
      "    public void setRegistered(boolean isRegistered) {\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:97
#, no-c-format
msgid "When using property level constraints property access strategy is used to access the value to be validated. This means the bean validation provider accesses the state via the property accessor method."
msgstr ""

#. Tag: para
#: usingvalidator.xml:102
#, no-c-format
msgid "It is recommended to stick either to field <emphasis>or</emphasis> property annotation within one class. It is not recommended to annotate a field <emphasis>and</emphasis> the accompanying getter method as this would cause the field to be validated twice."
msgstr ""

#. Tag: title
#: usingvalidator.xml:111
#, no-c-format
msgid "Class-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:114
#, no-c-format
msgid "Last but not least, a constraint can also be placed on class level. When a constraint annotation is placed on this level the class instance itself passed to the <classname>ConstraintValidator</classname>. Class level constraints are useful if it is necessary to inspect more than a single property of the class to validate it or if a correlation between different state variables has to be evaluated. In <xref linkend=\"example-class-level\"/> we add the property <property>passengers</property> to the class <classname>Car</classname>. We also add the constraint <classname>PassengerCount</classname> on the class level. We will later see how we can actually create this custom constraint (see <xref linkend=\"validator-customconstraints\"/>). For now we it is enough to know that <classname>PassengerCount</classname> will ensure that there cannot be more passengers in a car than there are seats."
msgstr ""

#. Tag: title
#: usingvalidator.xml:130
#, no-c-format
msgid "Class level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:132
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.Min;\n"
      "import javax.validation.constraints.NotNull;\n"
      "import javax.validation.constraints.Size;\n"
      "\n"
      "@PassengerCount\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "    \n"
      "    private List&lt;Person&gt; passengers;\n"
      "    \n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:137
#, no-c-format
msgid "Constraint inheritance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:139
#, no-c-format
msgid "When validating an object that implements an interface or extends another class, all constraint annotations on the implemented interface and parent class apply in the same manner as the constraints specified on the validated object itself. To make things clearer let's have a look at the following example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:146
#, no-c-format
msgid "Constraint inheritance using RentalCar"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:148
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class RentalCar extends Car {\n"
      "\n"
      "    private String rentalStation;\n"
      "    \n"
      "    public RentalCar(String manufacturer, String rentalStation) {\n"
      "        super(manufacturer);\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "    \n"
      "    @NotNull\n"
      "    public String getRentalStation() {\n"
      "        return rentalStation;\n"
      "    }\n"
      "\n"
      "    public void setRentalStation(String rentalStation) {\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:151
#, no-c-format
msgid "Our well-known class <classname>Car</classname> is now extended by <classname>RentalCar</classname> with the additional property <property>rentalStation</property>. If an instance of <classname>RentalCar</classname> is validated, not only the <classname>@NotNull</classname> constraint on <property>rentalStation</property> is validated, but also the constraint on <property>manufacturer</property> from the parent class."
msgstr ""

#. Tag: para
#: usingvalidator.xml:159
#, no-c-format
msgid "The same would hold true, if <classname>Car</classname> were an interface implemented by <classname>RentalCar</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:162
#, no-c-format
msgid "Constraint annotations are aggregated if methods are overridden. If <classname>RentalCar</classname> would override the <methodname>getManufacturer()</methodname> method from <classname>Car</classname> any constraints annotated at the overriding method would be evaluated in addition to the <classname>@NotNull</classname> constraint from the super-class."
msgstr ""

#. Tag: title
#: usingvalidator.xml:171
#, no-c-format
msgid "Object graphs"
msgstr ""

#. Tag: para
#: usingvalidator.xml:173
#, no-c-format
msgid "The Bean Validation API does not only allow to validate single class instances but also complete object graphs. To do so, just annotate a field or property representing a reference to another object with <classname>@Valid</classname>. If the parent object is validated, all referenced objects annotated with <classname>@Valid</classname> will be validated as well (as will be their children etc.). See <xref linkend=\"example-car-with-driver\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:182
#, no-c-format
msgid "Class Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:184
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    @NotNull\n"
      "    private String name;\n"
      "    \n"
      "    public Person(String name) {\n"
      "        super();\n"
      "        this.name = name;\n"
      "    }\n"
      "\n"
      "    public String getName() {\n"
      "        return name;\n"
      "    }\n"
      "\n"
      "    public void setName(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:188
#, no-c-format
msgid "Adding a driver to the car"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:190
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private Person driver;\n"
      "    \n"
      "    public Car(Person driver) {\n"
      "        this.driver = driver;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:193
#, no-c-format
msgid "If an instance of <classname>Car</classname> is validated, the referenced <classname>Person</classname> object will be validated as well, as the <property>driver</property> field is annotated with <classname>@Valid</classname>. Therefore the validation of a <classname>Car</classname> will fail if the <property>name</property> field of the referenced <classname>Person</classname> instance is <code>null</code>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:201
#, no-c-format
msgid "Object graph validation also works for collection-typed fields. That means any attributes that"
msgstr ""

#. Tag: para
#: usingvalidator.xml:206
#, no-c-format
msgid "are arrays"
msgstr ""

#. Tag: para
#: usingvalidator.xml:210
#, no-c-format
msgid "implement <classname>java.lang.Iterable</classname> (especially <classname>Collection</classname>, <classname>List</classname> and <classname>Set</classname>)"
msgstr ""

#. Tag: para
#: usingvalidator.xml:216
#, no-c-format
msgid "implement <classname>java.util.Map</classname>"
msgstr ""

#. Tag: para
#: usingvalidator.xml:220
#, no-c-format
msgid "can be annotated with <classname>@Valid</classname>, which will cause each contained element to be validated, when the parent object is validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:225
#, no-c-format
msgid "Car with a list of passengers"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:227
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import java.util.ArrayList;\n"
      "import java.util.List;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();\n"
      "\n"
      "    public Car(List&lt;Person&gt; passengers) {\n"
      "        this.passengers = passengers;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:230
#, no-c-format
msgid "If a <classname>Car</classname> instance is validated, a <classname>ConstraintValidation</classname> will be created, if any of the <classname>Person</classname> objects contained in the <property>passengers</property> list has a <code>null</code> name."
msgstr ""

#. Tag: para
#: usingvalidator.xml:234
#, no-c-format
msgid "<classname>null</classname> values are getting ignored when validating object graphs."
msgstr ""

#. Tag: title
#: usingvalidator.xml:241
#, no-c-format
msgid "Validating constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:243
#, no-c-format
msgid "The <classname>Validator</classname> interface is the main entry point to Bean Validation. In <xref linkend=\"section-validator-instance\"/> we will first show how to obtain an <classname>Validator</classname> instance. Afterwards we will learn how to use the different methods of the <classname>Validator</classname> interface."
msgstr ""

#. Tag: title
#: usingvalidator.xml:250
#, no-c-format
msgid "Obtaining a <classname>Validator</classname> instance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:252
#, no-c-format
msgid "The first step towards validating an entity instance is to get hold of a <classname>Validator</classname> instance. The road to this instance leads via the <classname>Validation</classname> class and a <classname>ValidatorFactory</classname>. The easiest way is to use the static <methodname>Validation.buildDefaultValidatorFactory()</methodname> method:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:261
#, no-c-format
msgid "Validation.buildDefaultValidatorFactory()"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:263
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();"
msgstr ""

#. Tag: para
#: usingvalidator.xml:266
#, no-c-format
msgid "For other ways of obtaining a Validator instance see <xref linkend=\"validator-bootstrapping\"/>. For now we just want to see how we can use the <classname>Validator</classname> instance to validate entity instances."
msgstr ""

#. Tag: title
#: usingvalidator.xml:273
#, no-c-format
msgid "Validator methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:275
#, no-c-format
msgid "The <classname>Validator</classname> interface contains three methods that can be used to either validate entire entities or just a single properties of the entity."
msgstr ""

#. Tag: para
#: usingvalidator.xml:279
#, no-c-format
msgid "All three methods return a <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty, if the validation succeeds. Otherwise a <classname>ConstraintViolation</classname> instance is added for each violated constraint."
msgstr ""

#. Tag: para
#: usingvalidator.xml:285
#, no-c-format
msgid "All the validation methods have a var-args parameter which can be used to specify, which validation groups shall be considered when performing the validation. If the parameter is not specified the default validation group (<classname>javax.validation.groups.Default</classname>) will be used. We will go into more detail on the topic of validation groups in"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:294
#, no-c-format
msgid "validate"
msgstr ""

#. Tag: para
#: usingvalidator.xml:296
#, no-c-format
msgid "Use the <methodname>validate()</methodname> method to perform validation of all constraints of a given entity instance (see <xref linkend=\"example-validator-validate\"/> )."
msgstr ""

#. Tag: title
#: usingvalidator.xml:301
#, no-c-format
msgid "Usage of <methodname>Validator.validate()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:304
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:309
#, no-c-format
msgid "validateProperty"
msgstr ""

#. Tag: para
#: usingvalidator.xml:311
#, no-c-format
msgid "With help of the <methodname>validateProperty()</methodname> a single named property of a given object can be validated. The property name is the JavaBeans property name."
msgstr ""

#. Tag: title
#: usingvalidator.xml:316
#, no-c-format
msgid "Usage of <methodname>Validator.validateProperty()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:319
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, \"manufacturer\");\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:322
#, no-c-format
msgid "<methodname>Validator.validateProperty</methodname> is for example used in the integration of Bean Validation into JSF 2 (see <xref linkend=\"section-presentation-layer\"/>)."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:328
#, no-c-format
msgid "validateValue"
msgstr ""

#. Tag: para
#: usingvalidator.xml:330
#, no-c-format
msgid "Using the <methodname>validateValue() </methodname>method you can check, whether a single property of a given class can be validated successfully, if the property had the specified value:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:335
#, no-c-format
msgid "Usage of <methodname>Validator.validateValue()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:338
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, \"manufacturer\", null);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:342
#, no-c-format
msgid "<classname>@Valid</classname> is not honored by <methodname>validateProperty()</methodname> or <methodname>validateValue()</methodname>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:350
#, no-c-format
msgid "<classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:352
#, no-c-format
msgid "Now it is time to have a closer look at what a <classname>ConstraintViolation</classname>. Using the different methods of <classname>ConstraintViolation</classname> a lot of useful information about the cause of the validation failure can be determined. <xref linkend=\"table-constraint-violation\"/> gives an overview of these methods:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:360
#, no-c-format
msgid "The various <classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:366
#, no-c-format
msgid "Method"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:368
#, no-c-format
msgid "Usage"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:370
#, no-c-format
msgid "Example (referring to <xref linkend=\"example-validator-validate\"/>)"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:377
#, no-c-format
msgid "getMessage()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:379
#, no-c-format
msgid "The interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:381
#, no-c-format
msgid "may not be null"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:385
#, no-c-format
msgid "getMessageTemplate()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:387
#, no-c-format
msgid "The non-interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:389
#, no-c-format
msgid "{javax.validation.constraints.NotNull.message}"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:393
#, no-c-format
msgid "getRootBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:395
#, no-c-format
msgid "The root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:397 usingvalidator.xml:415
#, no-c-format
msgid "<entry>car</entry>"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:401
#, no-c-format
msgid "getRootBeanClass()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:403
#, no-c-format
msgid "The class of the root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:405
#, no-c-format
msgid "Car.class"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:409
#, no-c-format
msgid "getLeafBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:411
#, no-c-format
msgid "If a bean constraint, the bean instance the constraint is applied on. If a property constraint, the bean instance hosting the property the constraint is applied on."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:419
#, no-c-format
msgid "getPropertyPath()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:421
#, no-c-format
msgid "The property path to the value from root bean."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:427
#, no-c-format
msgid "getInvalidValue()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:429
#, no-c-format
msgid "The value failing to pass the constraint."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:431
#, no-c-format
msgid "passengers"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:435
#, no-c-format
msgid "getConstraintDescriptor()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:437
#, no-c-format
msgid "Constraint metadata reported to fail."
msgstr ""

#. Tag: title
#: usingvalidator.xml:447
#, no-c-format
msgid "Message interpolation"
msgstr ""

#. Tag: para
#: usingvalidator.xml:449
#, no-c-format
msgid "As we will see in <xref linkend=\"validator-customconstraints\"/> each constraint definition must define a default message descriptor. This message can be overridden at declaration time using the <methodname>message</methodname> attribute of the constraint. You can see this in <xref linkend=\"example-driver\"/>. This message descriptors get interpolated when a constraint validation fails using the configured <classname>MessageInterpolator</classname>. The interpolator will try to resolve any message parameters, meaning string literals enclosed in braces. In order to resolve these parameters Hibernate Validator's default <classname>MessageInterpolator</classname> first recursively resolves parameters against a custom <classname>ResourceBundle</classname> called <filename>ValidationMessages.properties</filename> at the root of the classpath (It is up to you to create this file). If no further replacements are possible against the custom bundle the default <classname>ResourceBundle</classname> under <filename>/org/hibernate/validator/ValidationMessages.properties</filename> gets evaluated. If a replacement occurs against the default bundle the algorithm looks again at the custom bundle (and so on). Once no further replacements against these two resource bundles are possible remaining parameters are getting resolved against the attributes of the constraint to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:472
#, no-c-format
msgid "Since the braces { and } have special meaning in the messages they need to be escaped if they are used literally. The following The following rules apply:"
msgstr ""

#. Tag: para
#: usingvalidator.xml:476
#, no-c-format
msgid "\\{ is considered as the literal {"
msgstr ""

#. Tag: para
#: usingvalidator.xml:480
#, no-c-format
msgid "\\} is considered as the literal }"
msgstr ""

#. Tag: para
#: usingvalidator.xml:484
#, no-c-format
msgid "\\\\ is considered as the literal \\"
msgstr ""

#. Tag: para
#: usingvalidator.xml:488
#, no-c-format
msgid "If the default message interpolator does not fit your requirements it is possible to plug a custom <classname>MessageInterpolator</classname> when the <classname>ValidatorFactory</classname> gets created. This can be seen in <xref linkend=\"validator-bootstrapping\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:497
#, no-c-format
msgid "Validating groups"
msgstr ""

#. Tag: para
#: usingvalidator.xml:499
#, no-c-format
msgid "Groups allow you to restrict the set of constraints applied during validation. This makes for example wizard like validation possible where in each step only a specified subset of constraints get validated. The groups targeted are passed as var-args parameters to <methodname>validate</methodname>, <methodname>validateProperty</methodname> and <methodname>validateValue</methodname>. Let's have a look at an extended <classname>Car</classname> with <classname>Driver</classname> example. First we have the class <classname>Person</classname> (<xref linkend=\"example-person\"/>) which has a <classname>@NotNull </classname>constraint on <property>name</property>. Since no group is specified for this annotation its default group is <classname>javax.validation.groups.Default</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:514
#, no-c-format
msgid "When more than one group is requested, the order in which the groups are evaluated is not deterministic. If no group is specified the default group <classname>javax.validation.groups.Default</classname> is assumed."
msgstr ""

#. Tag: title
#: usingvalidator.xml:521
#, no-c-format
msgid "Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:523
#, no-c-format
msgid ""
      "public class Person {\n"
      "    @NotNull\n"
      "    private String name;\n"
      "\n"
      "    public Person(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "    // getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:526
#, no-c-format
msgid "Next we have the class <classname>Driver</classname> (<xref linkend=\"example-driver\"/>) extending <classname>Person</classname>. Here we are adding the properties <property>age</property> and <property>hasDrivingLicense</property>. In order to drive you must be at least 18 (<classname>@Min(18)</classname>) and you must have a driving license (<classname>@AssertTrue</classname>). Both constraints defined on these properties belong to the group <classname>DriverChecks</classname>. As you can see in <xref linkend=\"example-group-interfaces\"/> the group <classname>DriverChecks</classname> is just a simple tagging interface. Using interfaces makes the usage of groups type safe and allows for easy refactoring. It also means that groups can inherit from each other via class inheritance."
msgstr ""

#. Tag: para
#: usingvalidator.xml:540
#, no-c-format
msgid "The Bean Validation specification does not enforce that groups have to be interfaces. Non interface classes could be used as well, but we recommend to stick to interfaces."
msgstr ""

#. Tag: title
#: usingvalidator.xml:546
#, no-c-format
msgid "Driver"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:548
#, no-c-format
msgid ""
      "public class Driver extends Person {\n"
      "    @Min(value = 18, message = \"You have to be 18 to drive a car\", groups = DriverChecks.class)\n"
      "    public int age;\n"
      "\n"
      "    @AssertTrue(message = \"You first have to pass the driving test\", groups = DriverChecks.class)\n"
      "    public boolean hasDrivingLicense;\n"
      "\n"
      "    public Driver(String name) {\n"
      "        super( name );\n"
      "    }\n"
      "\n"
      "    public void passedDrivingTest(boolean b) {\n"
      "        hasDrivingLicense = b;\n"
      "    }\n"
      "\n"
      "    public int getAge() {\n"
      "        return age;\n"
      "    }\n"
      "\n"
      "    public void setAge(int age) {\n"
      "        this.age = age;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:552
#, no-c-format
msgid "Group interfaces"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:554
#, no-c-format
msgid ""
      "public interface DriverChecks {\n"
      "}\n"
      "\n"
      "public interface CarChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:557
#, no-c-format
msgid "Last but not least we add the property <property>passedVehicleInspection</property> to the <classname>Car</classname> class (<xref linkend=\"example-car\"/>) indicating whether a car passed the road worthy tests."
msgstr ""

#. Tag: title
#: usingvalidator.xml:563
#, no-c-format
msgid "<title>Car</title>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:565
#, no-c-format
msgid ""
      "public class Car {\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "\n"
      "    @AssertTrue(message = \"The car has to pass the vehicle inspection first\", groups = CarChecks.class)\n"
      "    private boolean passedVehicleInspection;\n"
      "\n"
      "    @Valid\n"
      "    private Driver driver;\n"
      "\n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:568
#, no-c-format
msgid "Overall three different groups are used in our example. <property>Person.name</property>, <property>Car.manufacturer</property>, <property>Car.licensePlate</property> and <property>Car.seatCount</property> all belong to the <classname>Default</classname> group. <property>Driver.age</property> and <property>Driver.hasDrivingLicense</property> belong to <classname>DriverChecks</classname> and last but not least <property>Car.passedVehicleInspection</property> belongs to the group <classname>CarChecks</classname>. <xref linkend=\"example-drive-away\"/> shows how passing different group combinations to the <methodname>Validator.validate</methodname> method result in different validation results."
msgstr ""

#. Tag: title
#: usingvalidator.xml:582
#, no-c-format
msgid "Drive away"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:584
#, no-c-format
msgid ""
      "public class GroupTest {\n"
      "\n"
      "    private static Validator validator;\n"
      "\n"
      "    @BeforeClass\n"
      "    public static void setUp() {\n"
      "        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "        validator = factory.getValidator();\n"
      "    }\n"
      "\n"
      "    @Test\n"
      "    public void driveAway() {\n"
      "        // create a car and check that everything is ok with it.\n"
      "        Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );\n"
      "        assertEquals( 0, constraintViolations.size() );\n"
      "\n"
      "        // but has it passed the vehicle inspection?\n"
      "        constraintViolations = validator.validate( car, CarChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals(\"The car has to pass the vehicle inspection first\", constraintViolations.iterator().next().getMessage());\n"
      "\n"
      "        // let's go to the vehicle inspection\n"
      "        car.setPassedVehicleInspection( true );\n"
      "        assertEquals( 0, validator.validate( car ).size() );\n"
      "\n"
      "        // now let's add a driver. He is 18, but has not passed the driving test yet\n"
      "        Driver john = new Driver( \"John Doe\" );\n"
      "        john.setAge( 18 );\n"
      "        car.setDriver( john );\n"
      "        constraintViolations = validator.validate( car, DriverChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals( \"You first have to pass the driving test\", constraintViolations.iterator().next().getMessage() );\n"
      "\n"
      "        // ok, John passes the test\n"
      "        john.passedDrivingTest( true );\n"
      "        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );\n"
      "\n"
      "        // just checking that everything is in order now\n"
      "        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:587
#, no-c-format
msgid "First we create a car and validate it using no explicit group. There are no validation errors, even though the property <property>passedVehicleInspection</property> is per default <constant>false</constant>. However, the constraint defined on this property does not belong to the default group. Next we just validate the <classname>CarChecks</classname> group which will fail until we make sure that the car passes the vehicle inspection. When we then add a driver to the car and validate against <classname>DriverChecks</classname> we get again a constraint violation due to the fact that the driver has not yet passed the driving test. Only after setting <property>passedDrivingTest</property> to true the validation against <classname>DriverChecks</classname> will pass."
msgstr ""

#. Tag: para
#: usingvalidator.xml:600
#, no-c-format
msgid "Last but not least, we show that all constraints are passing by validating against all defined groups."
msgstr ""

#. Tag: title
#: usingvalidator.xml:604
#, no-c-format
msgid "Group sequences"
msgstr ""

#. Tag: para
#: usingvalidator.xml:606
#, no-c-format
msgid "By default, constraints are evaluated in no particular order and this regardless of which groups they belong to. In some situations, however, it is useful to control the order of the constraint evaluation. In our example from <xref linkend=\"validator-usingvalidator-validationgroups\"/> we could for example require that first all default car constraints are passing before we check the road worthiness of the car. Finally before we drive away we check the actual driver constraints. In order to implement such an order one would define a new interface and annotate it with <classname>@GroupSequence</classname> defining the order in which the groups have to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:619
#, no-c-format
msgid "If at least one constraints fails in a sequenced group none of the constraints of the following groups in the sequence get validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:625
#, no-c-format
msgid "Interface with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:627
#, no-c-format
msgid ""
      "@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})\n"
      "public interface OrderedChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:631
#, no-c-format
msgid "Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency either directly or indirectly, either through cascaded sequence definition or group inheritance. If a group containing such a circularity is evaluated, a <classname>GroupDefinitionException</classname> is raised."
msgstr ""

#. Tag: para
#: usingvalidator.xml:635
#, no-c-format
msgid "The usage of the new sequence could then look like in <xref linkend=\"example-group-sequence\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:640
#, no-c-format
msgid "Usage of a group sequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:642
#, no-c-format
msgid ""
      "@Test\n"
      "public void testOrderedChecks() {\n"
      "    Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "    car.setPassedVehicleInspection( true );\n"
      "\n"
      "    Driver john = new Driver( \"John Doe\" );\n"
      "    john.setAge( 18 );\n"
      "    john.passedDrivingTest( true );\n"
      "    car.setDriver( john );\n"
      "\n"
      "    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:647
#, no-c-format
msgid "Redefining the default group sequence of a class"
msgstr ""

#. Tag: title
#: usingvalidator.xml:650
#, no-c-format
msgid "@GroupSequence"
msgstr ""

#. Tag: para
#: usingvalidator.xml:652
#, no-c-format
msgid "The <classname>@GroupSequence</classname> annotation also fulfills a second purpose. It allows you to redefine what the <constant>Default</constant> group means for a given class. To redefine <classname>Default</classname> for a given class, add a <classname>@GroupSequence</classname> annotation to the class. The defined groups in the annotation express the sequence of groups that substitute <classname>Default</classname> for this class. <xref linkend=\"example-rental-car\"/> introduces a new class <classname>RentalCar</classname> with a redfined default group. With this definition the check for all three groups can be rewritten as seen in <xref linkend=\"example-testOrderedChecksWithRedefinedDefault\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:666
#, no-c-format
msgid "RentalCar with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:668
#, no-c-format
msgid ""
      "@GroupSequence({ RentalCar.class, CarChecks.class, DriverChecks.class })\n"
      "public class RentalCar extends Car {\n"
      "    private boolean rented;    \n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "   public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(booelan rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:672
#, no-c-format
msgid "testOrderedChecksWithRedefinedDefault"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:674
#, no-c-format
msgid ""
      "@Test\n"
      "public void testOrderedChecksWithRedefinedDefault() {\n"
      "    RentalCar rentalCar = new RentalCar( \"Morris\", \"DD-AB-123\", 2 );\n"
      "    rentalCar.setPassedVehicleInspection( true );\n"
      "\n"
      "    Driver john = new Driver( \"John Doe\" );\n"
      "    john.setAge( 18 );\n"
      "    john.passedDrivingTest( true );\n"
      "    rentalCar.setDriver( john );\n"
      "\n"
      "    assertEquals( 0, validator.validate( rentalCar, Default.class ).size() );\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:678
#, no-c-format
msgid "Due to the fact that there cannot be a cyclic dependency in the group and group sequence definitions one cannot just add <classname>Default</classname> to the sequence redefining <classname>Default</classname> for a class. Instead the class itself should be added!"
msgstr ""

#. Tag: title
#: usingvalidator.xml:687
#, no-c-format
msgid "@GroupSequenceProvider"
msgstr ""

#. Tag: para
#: usingvalidator.xml:689
#, no-c-format
msgid "The <classname>@javax.validation.GroupSequence</classname> annotation is a standardized Bean Validation annotation. As seen in the previous section it allows you to statically redefine the default group sequence for a class. Hibernate Validator also offers a custom, non standardized annotation - <classname>org.hibernate.validator.group.GroupSequenceProvider </classname>- which allows for dynamic redefinition of the default group sequence. Using the rental car scenario again, one could dynamically add the driver checks depending on whether the car is rented or not. <xref linkend=\"example-rental-car-group-sequence-provider\"/> and <xref linkend=\"example-group-sequence-provider-implementation\"/> show how this use-case would be implemented."
msgstr ""

#. Tag: title
#: usingvalidator.xml:704
#, no-c-format
msgid "RentalCar with @GroupSequenceProvider"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:706
#, no-c-format
msgid ""
      "@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)\n"
      "public class RentalCar extends Car {\n"
      "    private boolean rented;    \n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "   public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(boolean rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:710
#, no-c-format
msgid "DefaultGroupSequenceProvider implementation"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:712
#, no-c-format
msgid ""
      "public class RentalCarGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {\n"
      "    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {\n"
      "        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();\n"
      "        defaultGroupSequence.add( RentalCar.class, CarChecks.class );\n"
      "\n"
      "        if ( car != null &amp;&amp; car.isRented() ) {\n"
      "            defaultGroupSequence.add( DriverChecks.class );\n"
      "        }\n"
      "\n"
      "        return defaultGroupSequence;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:719 usingvalidator.xml:727
#, no-c-format
msgid "Built-in constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:721
#, no-c-format
msgid "Hibernate Validator implements all of the default constraints specified in Bean Validation as well as some custom ones. <xref linkend=\"table-builtin-constraints\"/> list all constraints available in Hibernate Validator."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:734
#, no-c-format
msgid "Annotation"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:736
#, no-c-format
msgid "Part of Bean Validation Specification"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:738
#, no-c-format
msgid "Apply on"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:740
#, no-c-format
msgid "<entry>Use</entry>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:742
#, no-c-format
msgid "Hibernate Metadata impact"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:748
#, no-c-format
msgid "@AssertFalse"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:750 usingvalidator.xml:763 usingvalidator.xml:793 usingvalidator.xml:813 usingvalidator.xml:833 usingvalidator.xml:865 usingvalidator.xml:899 usingvalidator.xml:917 usingvalidator.xml:935 usingvalidator.xml:977 usingvalidator.xml:990 usingvalidator.xml:1010 usingvalidator.xml:1042 usingvalidator.xml:1096
#, no-c-format
msgid "<entry>yes</entry>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:752 usingvalidator.xml:765 usingvalidator.xml:937 usingvalidator.xml:950 usingvalidator.xml:979
#, no-c-format
msgid "field/property"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:754
#, no-c-format
msgid "Check that the annotated element is <constant>false</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:757 usingvalidator.xml:770 usingvalidator.xml:787 usingvalidator.xml:807 usingvalidator.xml:827 usingvalidator.xml:859 usingvalidator.xml:879 usingvalidator.xml:957 usingvalidator.xml:971 usingvalidator.xml:984 usingvalidator.xml:1004 usingvalidator.xml:1018 usingvalidator.xml:1036 usingvalidator.xml:1073 usingvalidator.xml:1090 usingvalidator.xml:1106
#, no-c-format
msgid "none"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:761
#, no-c-format
msgid "@AssertTrue"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:767
#, no-c-format
msgid "Check that the annotated element is <constant>true</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:774
#, no-c-format
msgid "@CreditCardNumber"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:776 usingvalidator.xml:852 usingvalidator.xml:885 usingvalidator.xml:948 usingvalidator.xml:963 usingvalidator.xml:1024 usingvalidator.xml:1058 usingvalidator.xml:1079
#, no-c-format
msgid "<entry>no</entry>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:778 usingvalidator.xml:1081
#, no-c-format
msgid "field/property. The supported type is <classname>String</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:781
#, no-c-format
msgid "Check that the annotated string passes the Luhn checksum test. Note, this validation aims to check for user mistake, not credit card validity! See also <ulink url=\"http://www.merriampark.com/anatomycc.htm\">Anatomy of Credit Card Numbers</ulink>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:791
#, no-c-format
msgid "@DecimalMax"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:795 usingvalidator.xml:815 usingvalidator.xml:835 usingvalidator.xml:901 usingvalidator.xml:919 usingvalidator.xml:1026
#, no-c-format
msgid "field/property. Supported types are <classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>String</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:802
#, no-c-format
msgid "The annotated element must be a number whose value must be lower or equal to the specified maximum. The parameter value is the string representation of the max value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:811
#, no-c-format
msgid "@DecimalMin"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:822
#, no-c-format
msgid "The annotated element must be a number whose value must be higher or equal to the specified minimum. The parameter value is the string representation of the min value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:831
#, no-c-format
msgid "@Digits(integer=, fraction=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:842
#, no-c-format
msgid "Check whether the property is a number having up to <literal>integer</literal> digits and <literal>fraction</literal> fractional digits."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:846
#, no-c-format
msgid "Define column precision and scale."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:850
#, no-c-format
msgid "@Email"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:854 usingvalidator.xml:887 usingvalidator.xml:1012
#, no-c-format
msgid "field/property. Needs to be a string."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:856
#, no-c-format
msgid "Check whether the specified string is a valid email address."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:863
#, no-c-format
msgid "@Future"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:867 usingvalidator.xml:992
#, no-c-format
msgid "field/property. Supported types are <classname>java.util.Date</classname>, <classname>java.util.Calendar</classname>; In addition to these types demanded by the BV specification Hibernate Validator provides support for any implements of <classname>org.joda.time.ReadablePartial</classname> and <classname>org.joda.time.ReadableInstant</classname>, if the <ulink url=\"http://joda-time.sourceforge.net/\">Joda Time</ulink> date/time API is on the class path."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:877
#, no-c-format
msgid "Checks whether the annotated date is in the future."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:883
#, no-c-format
msgid "@Length(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:889
#, no-c-format
msgid "Validate that the annotated string is between <parameter>min</parameter> and <parameter>max</parameter> included."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:893 usingvalidator.xml:1052
#, no-c-format
msgid "Column length will be set to max."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:897
#, no-c-format
msgid "@Max"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:908
#, no-c-format
msgid "Checks whether the annotated value is less than or equal to the specified maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:911 usingvalidator.xml:929
#, no-c-format
msgid "Add a check constraint on the column."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:915
#, no-c-format
msgid "@Min"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:926
#, no-c-format
msgid "Checks whether the annotated value is higher than or equal to the specified minimum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:933
#, no-c-format
msgid "@NotNull"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:939
#, no-c-format
msgid "Check that the annotated value is not <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:942
#, no-c-format
msgid "Column(s) are not null."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:946
#, no-c-format
msgid "@NotBlank"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:952
#, no-c-format
msgid "Check that the annotated string is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on strings and that trailing whitespaces are ignored."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:961
#, no-c-format
msgid "@NotEmpty"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:965
#, no-c-format
msgid "field/property. Supported types are String, Collection, Map and arrays."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:968
#, no-c-format
msgid "Check whether the annotated element is not <constant>null</constant> nor empty."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:975
#, no-c-format
msgid "@Null"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:981
#, no-c-format
msgid "Check that the annotated value is <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:988
#, no-c-format
msgid "@Past"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1002
#, no-c-format
msgid "Checks whether the annotated date is in the past."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1008
#, no-c-format
msgid "@Pattern(regex=, flag=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1014
#, no-c-format
msgid "Checks if the annotated string matches the regular expression <parameter>regex</parameter> considering the given flag <parameter>match</parameter>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1022
#, no-c-format
msgid "@Range(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1033
#, no-c-format
msgid "Check whether the annotated value lies between (inclusive) the specified minimum and maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1040
#, no-c-format
msgid "@Size(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1044
#, no-c-format
msgid "field/property. Supported types are <classname>String</classname>, <classname>Collection</classname>, <classname>Map</classname> and <classname>arrays</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1049
#, no-c-format
msgid "Check if the annotated element size is between min and max (inclusive)."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1056
#, no-c-format
msgid "@ScriptAssert(lang=, script=, alias=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1060
#, no-c-format
msgid "type"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1062
#, no-c-format
msgid "Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 (\"Scripting for the Java<superscript>TM</superscript> Platform\") must part of the class path. This is automatically the case when running on Java 6. For older Java versions, the JSR 223 RI can be added manually to the class path.The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1077
#, no-c-format
msgid "@URL(protocol=, host=, port=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1084
#, no-c-format
msgid "Check if the annotated string is a valid URL. If any of parameters <parameter>protocol</parameter>, <parameter>host</parameter> or <parameter>port</parameter> is specified the URL must match the specified values in the according part."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1094
#, no-c-format
msgid "@Valid"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1098
#, no-c-format
msgid "field/property. Any non-primitive types are supported."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1101
#, no-c-format
msgid "Performs validation recursively on the associated object. If the object is a collection or an array, the elements are validated recursively. If the object is a map, the value elements are validated recursively."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1113
#, no-c-format
msgid "On top of the parameters indicated in <xref linkend=\"table-builtin-constraints\"/> each constraint supports the parameters <parameter>message</parameter>, <parameter>groups</parameter> and <parameter>payload</parameter>. This is a requirement of the Bean Validation specification."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1120
#, no-c-format
msgid "In some cases these built-in constraints will not fulfill your requirements. In this case you can literally in a minute write your own constraints. We will discuss this in"
msgstr ""

