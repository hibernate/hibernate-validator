<?xml version="1.0" encoding="UTF-8"?>
<!--
	~ JBoss, Home of Professional Open Source
	~ Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
	~ by the @authors tag. See the copyright.txt in the distribution for a
	~ full listing of individual contributors.
	~
	~ Licensed under the Apache License, Version 2.0 (the "License");
	~ you may not use this file except in compliance with the License.
	~ You may obtain a copy of the License at
	~ http://www.apache.org/licenses/LICENSE-2.0
	~ Unless required by applicable law or agreed to in writing, software
	~ distributed under the License is distributed on an "AS IS" BASIS,
	~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	~ See the License for the specific language governing permissions and
	~ limitations under the License.
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hv.ent">
%BOOK_ENTITIES;
]>
<chapter id="validator-usingvalidator">
  <title>Validation step by step</title>

  <para>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - field-, property-, and class-level
    annotations.</para>

    <note>
      <para>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <classname>java.lang.annotation.Target</classname>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <xref
      linkend="validator-customconstraints"/> for more information.</para>
    </note>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can be expressed by annotating a field of a class.
      <xref linkend="example-field-level"/> shows a field level configuration
      example:</para>

      <example id="example-field-level">
        <title>Field level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be validated. This means the bean validation
      provider directly accesses the instance variable and does not invoke the
      property accessor method also if such a method exists.</para>

      <note>
        <para>The access type (private, protected or public) does not
        matter.</para>
      </note>

      <note>
        <para>Static fields and properties cannot be validated.</para>
      </note>

      <tip>
        <para>When validating byte code enhanced objects property level
        constraints should be used, because the byte code enhancing library
        won't be able to determine a field access via reflection.</para>
      </tip>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <xref linkend="example-property-level"/> uses the
      same entity as in <xref linkend="example-field-level"/>, however,
      property level constraints are used.<note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example id="example-property-level">
        <title>Property level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    @AssertTrue
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method. One
      advantage of annotating properties instead of fields is that the
      constraints become part of the constrained type's API that way and users
      are aware of the existing constraints without having to examine the
      type's implementation.</para>

      <tip>
        <para>It is recommended to stick either to field
        <emphasis>or</emphasis> property annotations within one class. It is
        not recommended to annotate a field <emphasis>and</emphasis> the
        accompanying getter method as this would cause the field to be
        validated twice.</para>
      </tip>
    </section>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <xref linkend="example-class-level"/>
      we add the property <property>passengers</property> to the class
      <classname>Car</classname>. We also add the constraint
      <classname>PassengerCount</classname> on the class level. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints"/>). For now it is enough to know
      that <classname>PassengerCount</classname> will ensure that there cannot
      be more passengers in a car than there are seats.</para>

      <example id="example-class-level">
        <title>Class level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@PassengerCount
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    private List&lt;Person&gt; passengers;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Constraint inheritance using RentalCar</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> is now extended by
      <classname>RentalCar</classname> with the additional property
      <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> is validated, but also the constraint
      on <property>manufacturer</property> from the parent class.</para>

      <para>The same would hold true, if <classname>Car</classname> were an
      interface implemented by <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      referenced objects annotated with <classname>@Valid</classname> will be
      validated as well (as will be their children etc.). See <xref
      linkend="example-car-with-driver"/>.</para>

      <example>
        <title>Class Person</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    @NotNull
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example id="example-car-with-driver">
        <title>Adding a driver to the car</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that</para>

      <itemizedlist>
        <listitem>
          <para>are arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs.</para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In <xref linkend="section-validator-instance"/>
    we will first show how to obtain an <classname>Validator</classname>
    instance. Afterwards we will learn how to use the different methods of the
    <classname>Validator</classname> interface.</para>

    <section id="section-obtaining-validator">
      <title>Obtaining a <classname>Validator</classname> instance</title>

      <para>The first step towards validating an entity instance is to get
      hold of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The easiest way is to use the
      static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:</para>

      <example>
        <title>Validation.buildDefaultValidatorFactory()</title>

        <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</programlisting>
      </example>

      <para>For other ways of obtaining a Validator instance see <xref
      linkend="validator-bootstrapping"/>. For now we just want to see how we
      can use the <classname>Validator</classname> instance to validate entity
      instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</para>

      <para>All three methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty,
      if the validation succeeds. Otherwise a
      <classname>ConstraintViolation</classname> instance is added for each
      violated constraint.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group
      (<classname>javax.validation.groups.Default</classname>) will be used.
      We will go into more detail on the topic of validation groups in <xref
      linkend="validator-usingvalidator-validationgroups"/></para>

      <section>
        <title><methodname>validate</methodname></title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given entity instance (see <xref
        linkend="example-validator-validate"/> ).</para>

        <example id="example-validator-validate">
          <title>Usage of
          <methodname>Validator.validate()</methodname></title>

          <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>
      </section>

      <section>
        <title><methodname>validateProperty</methodname></title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateProperty()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, "manufacturer");

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para><methodname>Validator.validateProperty</methodname> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <xref linkend="section-presentation-layer"/>).</para>
      </section>

      <section>
        <title><methodname>validateValue</methodname></title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateValue()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, "manufacturer", null);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <note>
          <para><classname>@Valid</classname> is not honored by
          <methodname>validateProperty()</methodname> or
          <methodname>validateValue()</methodname>.</para>
        </note>
      </section>
    </section>

    <section>
      <title><classname>ConstraintViolation</classname> methods</title>

      <para>Now it is time to have a closer look at what a
      <classname>ConstraintViolation</classname>. Using the different methods
      of <classname>ConstraintViolation</classname> a lot of useful
      information about the cause of the validation failure can be determined.
      <xref linkend="table-constraint-violation"/> gives an overview of these
      methods:</para>

      <table id="table-constraint-violation">
        <title>The various <classname>ConstraintViolation</classname>
        methods</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Method</entry>

              <entry>Usage</entry>

              <entry>Example (referring to <xref
              linkend="example-validator-validate"/>)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname>getMessage()</methodname></entry>

              <entry>The interpolated error message.</entry>

              <entry>may not be null</entry>
            </row>

            <row>
              <entry><methodname>getMessageTemplate()</methodname></entry>

              <entry>The non-interpolated error message.</entry>

              <entry>{javax.validation.constraints.NotNull.message}</entry>
            </row>

            <row>
              <entry><methodname>getRootBean()</methodname></entry>

              <entry>The root bean being validated.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getRootBeanClass()</methodname></entry>

              <entry>The class of the root bean being validated.</entry>

              <entry>Car.class</entry>
            </row>

            <row>
              <entry><methodname>getLeafBean()</methodname></entry>

              <entry>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getPropertyPath()</methodname></entry>

              <entry>The property path to the value from root bean.</entry>

              <entry/>
            </row>

            <row>
              <entry><methodname>getInvalidValue()</methodname></entry>

              <entry>The value failing to pass the constraint.</entry>

              <entry>passengers</entry>
            </row>

            <row>
              <entry><methodname>getConstraintDescriptor()</methodname></entry>

              <entry>Constraint metadata reported to fail.</entry>

              <entry/>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="section-message-interpolation">
      <title>Message interpolation</title>

      <para>As we will see in <xref linkend="validator-customconstraints"/>
      each constraint definition must define a default message descriptor.
      This message can be overridden at declaration time using the
      <methodname>message</methodname> attribute of the constraint. You can
      see this in <xref linkend="example-driver"/>. This message descriptors
      get interpolated when a constraint validation fails using the configured
      <classname>MessageInterpolator</classname>. The interpolator will try to
      resolve any message parameters, meaning string literals enclosed in
      braces. In order to resolve these parameters Hibernate Validator's
      default <classname>MessageInterpolator</classname> first recursively
      resolves parameters against a custom
      <classname>ResourceBundle</classname> called
      <filename>ValidationMessages.properties</filename> at the root of the
      classpath (It is up to you to create this file). If no further
      replacements are possible against the custom bundle the default
      <classname>ResourceBundle</classname> under
      <filename>/org/hibernate/validator/ValidationMessages.properties</filename>
      gets evaluated. If a replacement occurs against the default bundle the
      algorithm looks again at the custom bundle (and so on). Once no further
      replacements against these two resource bundles are possible remaining
      parameters are getting resolved against the attributes of the constraint
      to be validated.</para>

      <para>Since the braces { and } have special meaning in the messages they
      need to be escaped if they are used literally. The following The
      following rules apply:<itemizedlist>
          <listitem>
            <para>\{ is considered as the literal {</para>
          </listitem>

          <listitem>
            <para>\} is considered as the literal }</para>
          </listitem>

          <listitem>
            <para>\\ is considered as the literal \</para>
          </listitem>
        </itemizedlist></para>

      <para>If the default message interpolator does not fit your requirements
      it is possible to plug a custom
      <classname>MessageInterpolator</classname> when the
      <classname>ValidatorFactory</classname> gets created. This can be seen
      in <xref linkend="validator-bootstrapping"/>.</para>
    </section>
  </section>

  <section id="validator-usingvalidator-validationgroups">
    <title>Validating groups</title>

    <para>Groups allow you to restrict the set of constraints applied during
    validation. This makes for example wizard like validation possible where
    in each step only a specified subset of constraints get validated. The
    groups targeted are passed as var-args parameters to
    <methodname>validate</methodname>,
    <methodname>validateProperty</methodname> and
    <methodname>validateValue</methodname>. Let's have a look at an extended
    <classname>Car</classname> with <classname>Driver</classname> example.
    First we have the class <classname>Person</classname> (<xref
    linkend="example-person"/>) which has a <classname>@NotNull
    </classname>constraint on <property>name</property>. Since no group is
    specified for this annotation its default group is
    <classname>javax.validation.groups.Default</classname>.</para>

    <note>
      <para>When more than one group is requested, the order in which the
      groups are evaluated is not deterministic. If no group is specified the
      default group <classname>javax.validation.groups.Default</classname> is
      assumed.</para>
    </note>

    <example id="example-person">
      <title>Person</title>

      <programlisting language="JAVA" role="JAVA">public class Person {
    @NotNull
    private String name;

    public Person(String name) {
        this.name = name;
    }
    // getters and setters ...
}</programlisting>
    </example>

    <para>Next we have the class <classname>Driver</classname> (<xref
    linkend="example-driver"/>) extending <classname>Person</classname>. Here
    we are adding the properties <property>age</property> and
    <property>hasDrivingLicense</property>. In order to drive you must be at
    least 18 (<classname>@Min(18)</classname>) and you must have a driving
    license (<classname>@AssertTrue</classname>). Both constraints defined on
    these properties belong to the group <classname>DriverChecks</classname>.
    As you can see in <xref linkend="example-group-interfaces"/> the group
    <classname>DriverChecks</classname> is just a simple tagging interface.
    Using interfaces makes the usage of groups type safe and allows for easy
    refactoring. It also means that groups can inherit from each other via
    class inheritance.</para>

    <example id="example-driver">
      <title>Driver</title>

      <programlisting language="JAVA" role="JAVA">public class Driver extends Person {
    @Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)
    public int age;

    @AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</programlisting>
    </example>

    <example id="example-group-interfaces">
      <title>Group interfaces</title>

      <programlisting language="JAVA" role="JAVA">public interface DriverChecks {
}

public interface CarChecks {
}</programlisting>
    </example>

    <para>Last but not least we add the property
    <property>passedVehicleInspection</property> to the
    <classname>Car</classname> class (<xref linkend="example-car"/>)
    indicating whether a car passed the road worthy tests.</para>

    <example id="example-car">
      <title>Car</title>

      <programlisting language="JAVA" role="JAVA">public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    @AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</programlisting>
    </example>

    <para>Overall three different groups are used in our example.
    <property>Person.name</property>, <property>Car.manufacturer</property>,
    <property>Car.licensePlate</property> and
    <property>Car.seatCount</property> all belong to the
    <classname>Default</classname> group. <property>Driver.age</property> and
    <property>Driver.hasDrivingLicense</property> belong to
    <classname>DriverChecks</classname> and last but not least
    <property>Car.passedVehicleInspection</property> belongs to the group
    <classname>CarChecks</classname>. <xref linkend="example-drive-away"/>
    shows how passing different group combinations to the
    <methodname>Validator.validate</methodname> method result in different
    validation results.</para>

    <example id="example-drive-away">
      <title>Drive away</title>

      <programlisting language="JAVA" role="JAVA">public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</programlisting>
    </example>

    <para>First we create a car and validate it using no explicit group. There
    are no validation errors, even though the property
    <property>passedVehicleInspection</property> is per default
    <constant>false</constant>. However, the constraint defined on this
    property does not belong to the default group. Next we just validate the
    <classname>CarChecks</classname> group which will fail until we make sure
    that the car passes the vehicle inspection. When we then add a driver to
    the car and validate against <classname>DriverChecks</classname> we get
    again a constraint violation due to the fact that the driver has not yet
    passed the driving test. Only after setting
    <property>passedDrivingTest</property> to true the validation against
    <classname>DriverChecks</classname> will pass.</para>

    <para>Last but not least, we show that all constraints are passing by
    validating against all defined groups.</para>

    <section>
      <title>Group sequences</title>

      <para>By default, constraints are evaluated in no particular order,
      regardless of which groups they belong to. In some situations, however,
      it is useful to control the order constraints are evaluated. In our
      example from <xref linkend="validator-usingvalidator-validationgroups"/>
      we could for example require that first all default car constraints are
      passing before we check the road worthiness of the car. Finally before
      we drive away we check the actual driver constraints. In order to
      implement such an order one would define a new interface and annotate it
      with <classname>@GroupSequence</classname> defining the order in which
      the groups have to be validated.</para>

      <note>
        <para>If at least one constraint fails in a sequenced group none of
        the constraints of the following groups in the sequence get
        validated.</para>
      </note>

      <example id="example-orderedChecks">
        <title>Interface with @GroupSequence</title>

        <programlisting language="JAVA" role="JAVA">@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})
public interface OrderedChecks {
}</programlisting>
      </example>

      <para><warning>
          <para>Groups defining a sequence and groups composing a sequence
          must not be involved in a cyclic dependency either directly or
          indirectly, either through cascaded sequence definition or group
          inheritance. If a group containing such a circularity is evaluated,
          a <classname>GroupDefinitionException</classname> is raised.</para>
        </warning>The usage of the new sequence could then look like in <xref
      linkend="example-group-sequence"/>.</para>

      <example id="example-group-sequence">
        <title>Usage of a group sequence</title>

        <programlisting language="JAVA" role="JAVA">@Test
public void testOrderedChecks() {
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    car.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    car.setDriver( john );

    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
}</programlisting>
      </example>
    </section>

    <section id="section-default-group-class">
      <title>Redefining the default group sequence of a class</title>

      <section>
        <title>@GroupSequence</title>

        <para>The <classname>@GroupSequence</classname> annotation also
        fulfills a second purpose. It allows you to redefine what the
        <constant>Default</constant> group means for a given class. To
        redefine <classname>Default</classname> for a given class, add a
        <classname>@GroupSequence</classname> annotation to the class. The
        defined groups in the annotation express the sequence of groups that
        substitute <classname>Default</classname> for this class. <xref
        linkend="example-rental-car"/> introduces a new class
        <classname>RentalCar</classname> with a redefined default group. With
        this definition you can evaluate the constraints belonging to
        <classname>RentalChecks</classname>, <classname>CarChecks</classname>
        and <classname>RentalCar</classname> by just requesting the
        <classname>Default</classname> group as seen in <xref
        linkend="example-testCarIsRented"/>.</para>

        <example id="example-rental-car">
          <title>RentalCar with @GroupSequence</title>

          <programlisting language="JAVA" role="JAVA">@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
public class RentalCar extends Car {
    @AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
    private boolean rented;

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

    public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}</programlisting>
        </example>

        <example id="example-testCarIsRented">
          <title>RentalCar with redefined default group</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Validating the default group leads to validation on the default group sequence of {@code RentalCar}.
 */
@Test
public void carIsRented() {
  RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
  rentalCar.setPassedVehicleInspection( true );
  rentalCar.setRented( true );

  Set&lt;ConstraintViolation&lt;RentalCar&gt;&gt; constraintViolations = validator.validate( rentalCar );

  assertEquals( 1, constraintViolations.size() );
  assertEquals(
    "Wrong message",
    "The car is currently rented out",
    constraintViolations.iterator().next().getMessage()
  );

  rentalCar.setRented( false );
  constraintViolations = validator.validate( rentalCar );

  assertEquals( 0, constraintViolations.size() );
}</programlisting>
        </example>

        <note>
          <para>Due to the fact that there cannot be a cyclic dependency in
          the group and group sequence definitions one cannot just add
          <classname>Default</classname> to the sequence redefining
          <classname>Default</classname> for a class. Instead the class itself
          has to be added!</para>
        </note>

        <note>
          <para>The <classname>Default</classname> group sequence overriding
          is local to the class it is defined on and is not propagated to the
          associated objects. This means in particular that adding
          <classname>DriverChecks</classname> to the default group sequence of
          <classname>RentalCar</classname> would not have any effects. Only
          the group <classname>Default</classname> will be propagated to the
          driver association when validation a rental car instance.</para>
        </note>
      </section>

      <section>
        <title>@GroupSequenceProvider</title>

        <para>The <classname>@javax.validation.GroupSequence</classname>
        annotation is a standardized Bean Validation annotation. As seen in
        the previous section it allows you to statically redefine the default
        group sequence for a class. Hibernate Validator also offers a custom,
        non standardized annotation -
        <classname>org.hibernate.validator.group.GroupSequenceProvider
        </classname>- which allows for dynamic redefinition of the default
        group sequence. Using the rental car scenario again, one could
        dynamically add the <classname>CarChecks</classname> as seen in <xref
        linkend="example-rental-car-group-sequence-provider"/> and <xref
        linkend="example-group-sequence-provider-implementation"/>.</para>

        <example id="example-rental-car-group-sequence-provider">
          <title>RentalCar with @GroupSequenceProvider</title>

          <programlisting language="JAVA" role="JAVA">@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {
    @AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
    private boolean rented;

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

    public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}</programlisting>
        </example>

        <example id="example-group-sequence-provider-implementation" label="">
          <title>DefaultGroupSequenceProvider implementation</title>

          <programlisting language="JAVA" role="JAVA">public class RentalCarGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {
    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {
        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();
        defaultGroupSequence.add( RentalCar.class );

        if ( car != null &amp;&amp; !car.isRented() ) {
            defaultGroupSequence.add( CarChecks.class );
        }

        return defaultGroupSequence;
    }
}</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section id="validator-defineconstraints-builtin">
    <title>Built-in constraints</title>

    <para>Hibernate Validator comprises a basic set of commonly used
    constraints. These are foremost the constraints defined by the Bean
    Validation specification (see <xref linkend="table-spec-constraints"/>).
    Additionally, Hibernate Validator provides useful custom constraints (see
    <xref linkend="table-custom-constraints"/> and <xref
    linkend="table-custom-country-constraints"/>).</para>

    <section id="validator-defineconstraints-spec">
      <title>Bean Validation constraints</title>

      <para><xref linkend="table-spec-constraints"/> shows purpose and
      supported data types of all constraints specified in the Bean Validation
      API. All these constraints apply to the field/property level, there are
      no class-level constraints defined in the Bean Validation specification.
      If you are using the Hibernate object-relational mapper, some of the
      constraints are taken into account when creating the DDL for your model
      (see column "Hibernate metadata impact").</para>

      <note>
        <para>Hibernate Validator allows some constraints to be applied to
        more data types than required by the Bean Validation specification
        (e.g. @Max can be applied to <classname>Strings</classname>). Relying
        on this feature can impact portability of your application between
        Bean Validation providers.</para>
      </note>

      <table id="table-spec-constraints">
        <title>Bean Validation constraints</title>

        <tgroup cols="4">
          <colspec align="left"/>

          <colspec align="left"/>

          <colspec align="left"/>

          <colspec align="left"/>

          <thead>
            <row>
              <entry>Annotation</entry>

              <entry>Supported data types</entry>

              <entry>Use</entry>

              <entry>Hibernate metadata impact</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>@AssertFalse</entry>

              <entry><classname>Boolean</classname>,
              <classname>boolean</classname></entry>

              <entry>Checks that the annotated element is
              <constant>false</constant>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@AssertTrue</entry>

              <entry><classname>Boolean</classname>,
              <classname>boolean</classname></entry>

              <entry>Checks that the annotated element is
              <constant>true</constant>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@DecimalMax</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number</classname> and
              <classname>CharSequence</classname>.</entry>

              <entry>The annotated element must be a number whose value must
              be lower or equal to the specified maximum. The parameter value
              is the string representation of the max value according to the
              <classname>BigDecimal</classname> string representation.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@DecimalMin</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number </classname>and
              <classname>CharSequence</classname>.</entry>

              <entry>The annotated element must be a number whose value must
              be higher or equal to the specified minimum. The parameter value
              is the string representation of the min value according to the
              <classname>BigDecimal</classname> string representation.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Digits(integer=, fraction=)</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number</classname> and
              <classname>CharSequence</classname>.</entry>

              <entry>Checks whether the annoted value is a number having up to
              <literal>integer</literal> digits and
              <literal>fraction</literal> fractional digits.</entry>

              <entry>Define column precision and scale.</entry>
            </row>

            <row>
              <entry>@Future</entry>

              <entry><classname>java.util.Date</classname>,
              <classname>java.util.Calendar</classname>; Additionally
              supported by HV, if the <ulink
              url="http://joda-time.sourceforge.net/">Joda Time</ulink>
              date/time API is on the class path: any implementations of
              <classname>ReadablePartial</classname> and
              <classname>ReadableInstant</classname>.</entry>

              <entry>Checks whether the annotated date is in the
              future.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Max</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type
              of<classname>CharSequence</classname> (the numeric value
              represented by the character sequence is evaluated), any
              sub-type of <classname>Number</classname>.</entry>

              <entry>Checks whether the annotated value is less than or equal
              to the specified maximum.</entry>

              <entry>Add a check constraint on the column.</entry>
            </row>

            <row>
              <entry>@Min</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>CharSequence</classname> (the numeric value
              represented by the char sequence is evaluated), any sub-type of
              <classname>Number</classname>.</entry>

              <entry>Checks whether the annotated value is higher than or
              equal to the specified minimum.</entry>

              <entry>Add a check constraint on the column.</entry>
            </row>

            <row>
              <entry>@NotNull</entry>

              <entry>Any type</entry>

              <entry>Checks that the annotated value is not
              <constant>null.</constant></entry>

              <entry>Column(s) are not null.</entry>
            </row>

            <row>
              <entry>@Null</entry>

              <entry>Any type</entry>

              <entry>Checks that the annotated value is
              <constant>null.</constant></entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Past</entry>

              <entry><classname>java.util.Date</classname>,
              <classname>java.util.Calendar</classname>; Additionally
              supported by HV, if the <ulink
              url="http://joda-time.sourceforge.net/">Joda Time</ulink>
              date/time API is on the class path: any implementations of
              <classname>ReadablePartial</classname> and
              <classname>ReadableInstant</classname>.</entry>

              <entry>Checks whether the annotated date is in the past.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Pattern(regex=, flag=)</entry>

              <entry><classname>String</classname>. Additionally supported by
              HV: any sub-type of <classname>CharSequence</classname>.</entry>

              <entry>Checks if the annotated string matches the regular
              expression <parameter>regex</parameter> considering the given
              flag <parameter>match</parameter>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Size(min=, max=)</entry>

              <entry><classname>String</classname>,
              <classname>Collection</classname>, <classname>Map</classname>
              and <classname>arrays</classname>. Additionally supported by HV:
              any sub-type of <classname>CharSequence</classname>.</entry>

              <entry>Checks if the annotated element's size is between min and
              max (inclusive).</entry>

              <entry>Column length will be set to max.</entry>
            </row>

            <row>
              <entry>@Valid</entry>

              <entry>Any non-primitive type</entry>

              <entry>Performs validation recursively on the associated object.
              If the object is a collection or an array, the elements are
              validated recursively. If the object is a map, the value
              elements are validated recursively.</entry>

              <entry>none</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <note>
        <para>On top of the parameters indicated in <xref
        linkend="table-spec-constraints"/> each constraint supports the
        parameters <parameter>message</parameter>,
        <parameter>groups</parameter> and <parameter>payload</parameter>. This
        is a requirement of the Bean Validation specification.</para>
      </note>
    </section>

    <section id="validator-defineconstraints-hv-constraints">
      <title>Additional constraints</title>

      <para>In addition to the constraints defined by the Bean Validation API
      Hibernate Validator provides several useful custom constraints which are
      listed in <xref linkend="table-custom-constraints"/>. With one exception
      also these constraints apply to the field/property level, only
      @ScriptAssert is a class-level constraint.</para>

      <table id="table-custom-constraints">
        <title>Custom constraints</title>

        <tgroup cols="4">
          <colspec align="left"/>

          <colspec align="left"/>

          <colspec align="left"/>

          <colspec align="left"/>

          <thead>
            <row>
              <entry>Annotation</entry>

              <entry>Supported data types</entry>

              <entry>Use</entry>

              <entry>Hibernate metadata impact</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>@CreditCardNumber</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks that the annotated character sequence passes the
              Luhn checksum test. Note, this validation aims to check for user
              mistakes, not credit card validity! See also <ulink
              url="http://www.merriampark.com/anatomycc.htm">Anatomy of Credit
              Card Numbers</ulink>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Email</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks whether the specified character sequence is a
              valid email address. The optional parameters
              <parameter>regexp</parameter> and <parameter>flags</parameter>
              allow to specify an additional regular expression (including
              regular expression flags) which the email must match.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Length(min=, max=)</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Validates that the annotated character sequence is
              between <parameter>min</parameter> and
              <parameter>max</parameter> included.</entry>

              <entry>Column length will be set to max.</entry>
            </row>

            <row>
              <entry>@ModCheck(modType=, multiplier=, startIndex=, endIndex=,
              checkDigitPosition=, ignoreNonDigitCharacters=)</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks that the digits within the annotated character
              sequence pass the mod 10 or mod 11 checksum algorithm.
              <constant>modType</constant> is used to select the modulo type
              and the <constant>multiplier</constant> determines the algorithm
              specific multiplier (see also <ulink
              url="http://en.wikipedia.org/wiki/Luhn_algorithm">Luhn
              algorithm</ulink>). <constant>startIndex</constant> and
              <constant>endIndex</constant> allow to only run the modulo
              algorithm on the specified sub-string.
              <constant>checkDigitPosition</constant> allows to use an
              arbitrary digit within the character sequence to be the check
              digit. If not specified it is assumed that the check digit is
              part of the specified range. Last but not least,
              <constant>ignoreNonDigitCharacters</constant> allows to ignore
              non digit characters.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@NotBlank</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks that the annotated character sequence is not null
              and the trimmed length is greater than 0. The difference to
              @NotEmpty is that this constraint can only be applied on strings
              and that trailing whitespaces are ignored.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@NotEmpty</entry>

              <entry><classname>CharSequence</classname>,
              <classname>Collection</classname>, <classname>Map</classname>
              and arrays</entry>

              <entry>Checks whether the annotated element is not
              <constant>null</constant> nor empty.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Range(min=, max=)</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>CharSequence</classname>,
              <classname>byte</classname>, <classname>short</classname>,
              <classname>int</classname>, <classname>long</classname> and the
              respective wrappers of the primitive types</entry>

              <entry>Checks whether the annotated value lies between
              (inclusive) the specified minimum and maximum.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@SafeHtml(whitelistType=, additionalTags=)</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks whether the annotated value contains potentially
              malicious fragments such as <code>&lt;script/&gt;</code>. In
              order to use this constraint, the <ulink
              url="http://jsoup.org/">jsoup</ulink> library must be part of
              the class path. With the <parameter>whitelistType</parameter>
              attribute predefined whitelist types can be chosen. You can also
              specify additional html tags for the whitelist with the
              <parameter>additionalTags</parameter> attribute.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@ScriptAssert(lang=, script=, alias=)</entry>

              <entry>Any type</entry>

              <entry>Checks whether the given script can successfully be
              evaluated against the annotated element. In order to use this
              constraint, an implementation of the Java Scripting API as
              defined by JSR 223 ("Scripting for the
              Java<superscript>TM</superscript> Platform") must part of the
              class path. The expressions to be evaluated can be written
              in any scripting or expression language, for which a JSR 223
              compatible engine can be found in the class path.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@URL(protocol=, host=, port=, regexp=, flags=)</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks if the annotated character sequence is a valid URL
              according to RFC2396. If any of the optional parameters
              <parameter>protocol</parameter>, <parameter>host</parameter> or
              <parameter>port</parameter> are specified, the corresponding URL
              fragments must match the specified values. The optional
              parameters <parameter>regexp</parameter> and
              <parameter>flags</parameter> allow to specify an additional
              regular expression (including regular expression flags) which
              the URL must match.</entry>

              <entry>none</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section>
        <title>Country specific constraints</title>

        <para>Hibernate Validator offers also some country specific
        constraints, e.g. for the validation of social security numbers. <note>
            <para>If you have to implement a country specific constraint,
            consider making it a contribution to Hibernate Validator!</para>
          </note></para>

        <table id="table-custom-country-constraints">
          <title>Custom country specific constraints</title>

          <tgroup cols="5">
            <colspec align="left"/>

            <colspec align="left"/>

            <colspec align="left"/>

            <colspec align="left"/>

            <colspec align="left"/>

            <thead>
              <row>
                <entry>Annotation</entry>

                <entry>Supported data types</entry>

                <entry>Use</entry>

                <entry>Country</entry>

                <entry>Hibernate metadata impact</entry>
              </row>
            </thead>

            <tbody valign="top">
              <row>
                <entry>@CNPJ</entry>

                <entry><classname>CharSequence</classname></entry>

                <entry>Checks that the annotated character sequence represents
                a Brazilian corporate tax payer registry number (Cadastro de
                Pessoa Juríeddica)</entry>

                <entry>Brazil</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>@CPF</entry>

                <entry><classname>CharSequence</classname></entry>

                <entry>Checks that the annotated character sequence represents
                a Brazilian individual taxpayer registry number (Cadastro de
                Pessoa Fídsica).</entry>

                <entry>Brazil</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>@TituloEleitoral</entry>

                <entry><classname>CharSequence</classname></entry>

                <entry>Checks that the annotated character sequence represents
                a Brazilian voter ID card number (<ulink
                url="http://ghiorzi.org/cgcancpf.htm">Título
                Eleitoral</ulink>).</entry>

                <entry>Brazil</entry>

                <entry>none</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <tip>
          <para>In some cases neither the Bean Validation constraints nor the
          custom constraints provided by Hibernate Validator will fulfill your
          requirements. In this case you can easily write your own constraint.
          We will discuss this in <xref
          linkend="validator-customconstraints"/>.</para>
        </tip>
      </section>
    </section>
  </section>
</chapter>
