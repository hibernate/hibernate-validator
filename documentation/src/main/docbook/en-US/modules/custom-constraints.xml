<?xml version="1.0" encoding="UTF-8"?>
<!--
	~ JBoss, Home of Professional Open Source
	~ Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
	~ by the @authors tag. See the copyright.txt in the distribution for a
	~ full listing of individual contributors.
	~
	~ Licensed under the Apache License, Version 2.0 (the "License");
	~ you may not use this file except in compliance with the License.
	~ You may obtain a copy of the License at
	~ http://www.apache.org/licenses/LICENSE-2.0
	~ Unless required by applicable law or agreed to in writing, software
	~ distributed under the License is distributed on an "AS IS" BASIS,
	~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	~ See the License for the specific language governing permissions and
	~ limitations under the License.
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hv.ent">
%BOOK_ENTITIES;
]>
<chapter id="validator-customconstraints">
  <title>Creating custom constraints</title>

  <para>Though the Bean Validation API defines a whole set of standard
  constraint annotations one can easily think of situations in which these
  standard annotations won't suffice. For these cases you are able to create
  custom constraints tailored to your specific validation requirements in a
  simple manner.</para>

  <section id="validator-customconstraints-simple">
    <title>Creating a simple constraint</title>

    <para>To create a custom constraint, the following three steps are
    required:</para>

    <itemizedlist>
      <listitem>
        <para>Create a constraint annotation</para>
      </listitem>

      <listitem>
        <para>Implement a validator</para>
      </listitem>

      <listitem>
        <para>Define a default error message</para>
      </listitem>
    </itemizedlist>

    <section id="validator-customconstraints-constraintannotation">
      <title>The constraint annotation</title>

      <para>Let's write a constraint annotation, that can be used to express
      that a given string shall either be upper case or lower case. We'll
      apply it later on to the <property>licensePlate</property> field of the
      <classname>Car</classname> class from <xref
      linkend="validator-gettingstarted"/> to ensure, that the field is always
      an upper-case string.</para>

      <para>First we need a way to express the two case modes. We might use
      <classname>String</classname> constants, but a better way to go is to
      use a Java 5 enum for that purpose:</para>

      <example>
        <title>Enum <classname>CaseMode</classname> to express upper vs. lower
        case</title>

        <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04;

public enum CaseMode {
	UPPER,
	LOWER;
}</programlisting>
      </example>

      <para>Now we can define the actual constraint annotation. If you've
      never designed an annotation before, this may look a bit scary, but
      actually it's not that hard:</para>

      <example id="example-defining-custom-constraint">
        <title>Defining the <classname>CheckCase</classname> constraint
        annotation</title>

        <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04;

@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = CheckCaseValidator.class)
@Documented
public @interface CheckCase {

	String message() default "{org.hibernate.validator.referenceguide.chapter04.CheckCase.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	CaseMode value();

	@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
	@Retention(RUNTIME)
	@Documented
	@interface List {
		CheckCase[] value();
	}
}</programlisting>
      </example>

      <para>An annotation type is defined using the <code>@interface</code>
      keyword. All attributes of an annotation type are declared in a
      method-like manner. The specification of the Bean Validation API
      demands, that any constraint annotation defines</para>

      <itemizedlist>
        <listitem>
          <para>an attribute <property>message</property> that returns the
          default key for creating error messages in case the constraint is
          violated</para>
        </listitem>

        <listitem>
          <para>an attribute <property>groups</property> that allows the
          specification of validation groups, to which this constraint belongs
          (see <xref linkend="chapter-groups"/>). This must default to an
          empty array of type <classname>Class&lt;?&gt;</classname>.</para>
        </listitem>

        <listitem>
          <para>an attribute <classname>payload</classname> that can be used
          by clients of the Bean Validation API to assign custom payload
          objects to a constraint. This attribute is not used by the API
          itself. An example for a custom payload could be the definition of a
          severity:</para>

          <programlisting language="JAVA" role="JAVA">public class Severity {
	public interface Info extends Payload {
	}

	public interface Error extends Payload {
	}
}

public class ContactDetails {
	@NotNull(message = "Name is mandatory", payload = Severity.Error.class)
	private String name;

	@NotNull(message = "Phone number not specified, but not mandatory",
			payload = Severity.Info.class)
	private String phoneNumber;

	// ...
}</programlisting>

          <para>Now a client can after the validation of a
          <classname>ContactDetails</classname> instance access the severity
          of a constraint using
          <methodname>ConstraintViolation.getConstraintDescriptor().getPayload()</methodname>
          and adjust its behaviour depending on the severity.</para>
        </listitem>
      </itemizedlist>

      <para>Besides these three mandatory attributes we add another one,
      <property>value</property>, allowing for the required case mode to be
      specified. The name <property>value</property> is a special one, which
      can be omitted when using the annotation, if it is the only attribute
      specified, as e.g. in <code>@CheckCase(CaseMode.UPPER)</code>.</para>

      <para>In addition we annotate the annotation type with a couple of meta
      annotations:</para>

      <itemizedlist>
        <listitem>
          <para><code>@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE
          })</code>: Defines the supported target element types for the
          constraint. <classname>@CheckCase</classname> may be used on fields
          (element type <classname>FIELD</classname>), JavaBeans properties as
          well as method return values (<classname>METHOD</classname>) and
          method/constructor parameters (<classname>PARAMETER</classname>). By
          adding the element type <classname>ANNOTATION_TYPE</classname>, we
          allow for the creation composed constraints (see <xref
          linkend="section-constraint-composition"/>) based on
          <classname>@CheckCase</classname>.</para>

          <para>Would we create a class-level constraint (see <xref
          linkend="validator-usingvalidator-classlevel"/>), the element type
          <classname>TYPE</classname> had to be used. Constraints targetting
          the return value of a constructor need to support the element type
          <classname>CONSTRUCTOR</classname>. Cross-parameter constraints (see
          TODO) which are used to validate all the parameters of a method or
          constructor together, must support <classname>METHOD</classname> or
          <classname>CONSTRUCTOR</classname>, respectively.</para>
        </listitem>

        <listitem>
          <para><code>@Retention(RUNTIME)</code>: Specifies, that annotations
          of this type will be available at runtime by the means of
          reflection</para>
        </listitem>

        <listitem>
          <para><code>@Constraint(validatedBy =
          CheckCaseValidator.class)</code>: Marks the annotation type as
          constraint annotation and specifies the validator to be used to
          validate elements annotated with <classname>@CheckCase</classname>.
          If a constraint may be used on several data types, several
          validators may be specified, one for each data type.</para>
        </listitem>

        <listitem>
          <para><code>@Documented</code>: Says, that the use of
          <classname>@CheckCase</classname> will be contained in the JavaDoc
          of elements annotated with it</para>
        </listitem>
      </itemizedlist>

      <para>Finally, there is an inner annotation type named
      <classname>List</classname>. This annotation allows to specify several
      <classname>@CheckCase</classname> annotations on the same element, e.g.
      with different validation groups and messages. Note that while also
      another name could be used, we follow the Bean Validation, which
      recommends to use the name <classname>List</classname> and make the
      annotation an inner annotation of the corresponding constraint
      type.</para>
    </section>

    <section id="validator-customconstraints-validator">
      <title id="section-constraint-validator">The constraint
      validator</title>

      <para>Next, we need to implement a constraint validator, which is able
      to validate elements with a <classname>@CheckCase</classname>
      annotation. To do so, we implement the interface
      <classname>ConstraintValidator</classname> as shown below:</para>

      <example id="example-constraint-validator">
        <title>Implementing a constraint validator for the constraint
        <classname>CheckCase</classname></title>

        <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		if ( caseMode == CaseMode.UPPER ) {
			return object.equals( object.toUpperCase() );
		}
		else {
			return object.equals( object.toLowerCase() );
		}
	}
}</programlisting>
      </example>

      <para>The <classname>ConstraintValidator</classname> interface defines
      two type parameters, which we set in our implementation. The first one
      specifies the annotation type to be validated (in our example
      <classname>CheckCase</classname>), the second one the type of elements,
      which the validator can handle (here
      <classname>String</classname>).</para>

      <para>In case a constraint annotation is allowed at elements of
      different types, a <classname>ConstraintValidator</classname> for each
      allowed type has to be implemented and registered at the constraint
      annotation as shown above.</para>

      <para>The implementation of the validator is straightforward. The
      <methodname>initialize()</methodname> method gives us access to the
      attribute values of the annotation to be validated. In the example we
      store the <classname>CaseMode</classname> in a field of the validator
      for further usage.</para>

      <para>In the <methodname>isValid()</methodname> method we implement the
      logic, that determines, whether a <classname>String</classname> is valid
      according to a given <classname>@CheckCase</classname> annotation or
      not. This decision depends on the case mode retrieved in
      <classname>initialize()</classname>. As the Bean Validation
      specification recommends, we consider <code>null</code> values as being
      valid. If <code>null</code> is not a valid value for an element, it
      should be annotated with <code>@NotNull</code> explicitly.</para>

      <section>
        <title>The ConstraintValidatorContext</title>

        <para><xref linkend="example-constraint-validator"/> relies on the
        default error message generation by just returning
        <constant>true</constant> or <constant>false</constant> from the
        <methodname>isValid</methodname> call. Using the passed
        <classname>ConstraintValidatorContext</classname> object it is
        possible to either add additional error messages or completely disable
        the default error message generation and solely define custom error
        messages. The <classname>ConstraintValidatorContext</classname> API is
        modeled as fluent interface and is best demonstrated with an
        example:</para>

        <example id="example-constraint-validator-context">
          <title>Use of ConstraintValidatorContext to define custom error
          messages</title>

          <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.constraintvalidatorcontext;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		boolean isValid;
		if ( caseMode == CaseMode.UPPER ) {
			isValid = object.equals( object.toUpperCase() );
		}
		else {
			isValid = object.equals( object.toLowerCase() );
		}

		if ( !isValid ) {
			constraintContext.disableDefaultConstraintViolation();
			constraintContext.buildConstraintViolationWithTemplate(
					"{org.hibernate.validator.referenceguide.chapter04.constraintvalidatorcontext.CheckCase.message}"
			)
					.addConstraintViolation();
		}

		return isValid;
	}
}</programlisting>
        </example>

        <para><xref linkend="example-constraint-validator-context" os=""/>
        shows how you can disable the default error message generation and add
        a custom error message using a specified message template. In this
        example the use of the
        <classname>ConstraintValidatorContext</classname> results in the same
        error message as the default error message generation. <tip>
            <para>It is important to add each configured constraint violation
            by calling <methodname>addConstraintViolation()</methodname>. Only
            after that the new constraint violation will be created.</para>
          </tip></para>

        <para>In case you are implementing a
        <classname>ConstraintValidator</classname> for a class-level
        constraint it is also possible to adjust the property path for the
        created constraint violations. This is important for the case where
        you validate multiple properties of the class or even traverse the
        object graph and want the constraint violation to point to one of the
        involved properties only. As an example, <xref
        linkend="example-custom-error"/> shows the validator of a custom
        class-level constraint <classname>@ValidPassengerCount</classname>
        which makes sure that a car has not more passengers than seats. If
        this constraint is violated, this violation is reported at the
        <property>passengers</property> property.</para>

        <example id="example-custom-error">
          <title>Adding new <classname>ConstraintViolation</classname> with
          custom property path</title>

          <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.custompath;

public class ValidPassengerCountValidator
		implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
		if ( car == null ) {
			return true;
		}

		boolean isValid = car.getPassengers().size() &lt;= car.getSeatCount();

		if ( !isValid ) {
			constraintValidatorContext.disableDefaultConstraintViolation();
			constraintValidatorContext
					.buildConstraintViolationWithTemplate( "{my.custom.template}" )
					.addPropertyNode( "passengers" ).addConstraintViolation();
		}

		return isValid;
	}
}</programlisting>
        </example>
      </section>
    </section>

    <section id="validator-customconstraints-errormessage">
      <title>The error message</title>

      <para>Finally we need to specify the error message, that shall be used,
      in case a <classname>@CheckCase</classname> constraint is violated. To
      do so, we add the following to our custom
      <filename>ValidationMessages.properties</filename> (see also <xref
      linkend="section-message-interpolation"/>)</para>

      <example>
        <title>Defining a custom error message for the
        <classname>CheckCase</classname> constraint</title>

        <programlisting>org.hibernate.validator.referenceguide.chapter04.CheckCase.message=Case mode must be {value}.</programlisting>
      </example>

      <para>If a validation error occurs, the validation runtime will use the
      default value, that we specified for the message attribute of the
      <classname>@CheckCase</classname> annotation to look up the error
      message in this file.</para>
    </section>

    <section id="validator-customconstraints-using">
      <title>Using the constraint</title>

      <para>Now that our first custom constraint is completed, we can use it
      in the <classname>Car</classname> class from the <xref
      linkend="validator-gettingstarted"/> chapter to specify that the
      <property>licensePlate</property> field shall only contain upper-case
      strings:</para>

      <example id="example-car-with-checkcase">
        <title>Applying the <classname>CheckCase</classname>
        constraint</title>

        <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04;

public class Car {

	@NotNull
	private final String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	@CheckCase(CaseMode.UPPER)
	private final String licensePlate;

	@Min(2)
	private final int seatCount;

	public Car ( String manufacturer, String licencePlate, int seatCount ) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	//getters and setters ...
}</programlisting>
      </example>

      <para>Finally let's demonstrate in a little test that the
      <classname>@CheckCase</classname> constraint is properly
      validated:</para>

      <example>
        <title>Testcase demonstrating the <classname>CheckCase</classname>
        validation</title>

        <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04;

public class CarTest {

	private static Validator validator;

	@BeforeClass
	public static void setUp() {
		ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		validator = factory.getValidator();
	}

	@Test
	public void testLicensePlateNotUpperCase() {

		Car car = new Car( "Morris", "dd-ab-123", 4 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );
		assertEquals( 1, constraintViolations.size() );
		assertEquals(
				"Case mode must be UPPER.",
				constraintViolations.iterator().next().getMessage()
		);
	}

	@Test
	public void carIsValid() {

		Car car = new Car( "Morris", "DD-AB-123", 4 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );

		assertEquals( 0, constraintViolations.size() );
	}
}</programlisting>
      </example>
    </section>
  </section>

  <section id="section-cross-parameter-constraints">
    <title>Cross-parameter constraints</title>

    <para>Bean Validation distinguishes between two different kinds of
    constraints.</para>

    <para>Generic constraints (which have been discussed so far) apply to the
    annotated element, e.g. a type, field, method parameter or return value
    etc. Cross-parameter constraints, in contrast, apply to the array of
    parameters of a method or constructor and can be used to express
    validation logic which depends on several parameter values.</para>

    <para>In order to define a cross-parameter constraint, its validator class
    must be annotated with
    <classname>@SupportedValidationTarget(ValidationTarget.PARAMETERS)</classname>.
    The type parameter <varname>T</varname> from the
    <classname>ConstraintValidator</classname> interface must resolve to
    either <classname>Object</classname> or <classname>Object[]</classname> in
    order to receive the array of method/constructor arguments in the
    <methodname>isValid()</methodname> method.</para>

    <para>The following example shows the definition of a cross-parameter
    constraint which can be used to check that two <classname>Date</classname>
    parameters of a method are in the correct order:</para>

    <example>
      <title>Cross-parameter constraint</title>

      <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.crossparameter;

@Constraint(validatedBy = ConsistentDateParameterValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ConsistentDateParameters {

	String message() default "{org.hibernate.validator.referenceguide.chapter04." +
			"crossparameter.ConsistentDateParameters.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</programlisting>
    </example>

    <para>The definition of a cross-parameter constraint isn't any different
    from defining a generic constraint, i.e. it must specify the members
    <methodname>message()</methodname>, <methodname>groups()</methodname> and
    <methodname>payload()</methodname> and be annotated with
    <classname>@Constraint</classname>. This meta annotation also specifies
    the corresponding validator, which is shown in <xref
    linkend="example-cross-parameter-validator"/>. Note that besides the
    element types <classname>METHOD</classname> and
    <classname>CONSTRUCTOR</classname> also
    <classname>ANNOTATION_TYPE</classname> is specified as target of the
    annotation, in order to enable the creation of composed constraints based
    on <classname>@ConsistentDateParameters</classname> (see <xref
    linkend="validator-customconstraints-compound"/>).</para>

    <para><note>
        <para>Cross-parameter constraints are specified directly on the
        declaration of a method or constructor, which is also the case for
        return value constraints. In order to improve code readability, it is
        therefore recommended to chose constraint names — such as
        <classname>@ConsistentDateParameters</classname> — which make the
        constraint target aparent.</para>
      </note></para>

    <example id="example-cross-parameter-validator">
      <title>Generic and cross-parameter constraint</title>

      <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.crossparameter;

@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ConsistentDateParameterValidator implements
		ConstraintValidator&lt;ConsistentDateParameters, Object[]&gt; {

	@Override
	public void initialize(ConsistentDateParameters constraintAnnotation) {
	}

	@Override
	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 2 ) {
			throw new IllegalArgumentException( "Illegal method signature" );
		}

		//leave null-checking to @NotNull on individual parameters
		if ( value[0] == null || value[1] == null ) {
			return true;
		}

		if ( !( value[0] instanceof Date ) || !( value[1] instanceof Date ) ) {
			throw new IllegalArgumentException(
					"Illegal method signature, expected two " +
							"parameters of type Date."
			);
		}

		return ( (Date) value[0] ).before( (Date) value[1] );
	}
}</programlisting>
    </example>

    <para>As discussed above, the validation target
    <varname>PARAMETERS</varname> must be configured for a cross-parameter
    validator by using the <classname>@SupportedValidationTarget</classname>
    annotation. Since a cross-parameter constraint could be applied to any
    method or constructor, it is considered a best practice to check for the
    expected number and types of parameters in the validator implementation.
    As with generic constraints, <literal>null</literal> parameters should be
    considered valid and <classname>@NotNull</classname> on the individual
    parameters should be used to make sure that parameters are not
    <literal>null</literal>.</para>

    <para>In rare situations a constraint is both, generic and
    cross-parameter. This is the case if a constraint has a validator class
    which is annotated with
    <classname>@SupportedValidationTarget({ValidationTarget.PARAMETERS,
    ValidationTarget.ANNOTATED_ELEMENT})</classname> or if it has a generic
    and a cross-parameter validator class.</para>

    <para>When declaring such a constraint on a method which has parameters
    and also a return value, the intended constraint target can't be
    determined. Constraints which are generic and cross-parameter at the same
    time, must therefore define a member
    <methodname>validationAppliesTo()</methodname> which allows the constraint
    user to specify the constraint's target as shown in <xref
    linkend="example-dual-cross-parameter-constraint"/>.</para>

    <example id="example-dual-cross-parameter-constraint">
      <title>Generic and cross-parameter constraint</title>

      <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.crossparameter;

@Constraint(validatedBy = {
		ScriptAssertObjectValidator.class,
		ScriptAssertParametersValidator.class
})
@Target({ TYPE, FIELD, PARAMETER, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ScriptAssert {

	String message() default "{org.hibernate.validator.referenceguide.chapter04." +
			"crossparameter.ScriptAssert.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	String script();

	ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
}</programlisting>
    </example>

    <para>The <classname>@ScriptAssert</classname> constraint has two
    validators (not shown), a generic and a cross-parameter one and thus
    defines the member <methodname>validationAppliesTo()</methodname>. The
    default value <varname>IMPLICIT</varname> allows to derive the target
    automatically in situations where this is possible (e.g. if the constraint
    is declared on a field or on a method which has parameters but no return
    value).</para>

    <para>If the target can not be determined implicitly, it must be set by
    the user to either <varname>PARAMETERS</varname> or
    <varname>RETURN_VALUE</varname> as shown in <xref
    linkend="example-dual-cross-parameter-constraint-usage"/>.</para>

    <example id="example-dual-cross-parameter-constraint-usage">
      <title>Specifying the target for a generic and cross-parameter
      constraint</title>

      <programlisting language="JAVA" role="JAVA">@ScriptAssert(script = "arg1.size() &lt;= arg0", validationAppliesTo = ConstraintTarget.PARAMETERS)
public Car buildCar(int seatCount, List&lt;Passenger&gt; passengers) {
	//...
}</programlisting>
    </example>
  </section>

  <section id="validator-customconstraints-compound">
    <title id="section-constraint-composition">Constraint composition</title>

    <para>In the following, we'll discuss how to create higher level
    constraints by composing several basic constraints.</para>

    <para>Looking at the <property>licensePlate</property> field of the
    <classname>Car</classname> class in <xref
    linkend="example-car-with-checkcase"/>, we see three constraint
    annotations already. In complexer scenarios, where even more constraints
    could be applied to one element, this might become a bit confusing easily.
    Furthermore, if we had a <property>licensePlate</property> field in
    another class, we would have to copy all constraint declarations to the
    other class as well, violating the DRY principle.</para>

    <para>This problem can be tackled using composed constraints. In the
    following we create a new constraint annotation
    <classname>@ValidLicensePlate</classname>, that comprises the constraints
    <classname>@NotNull</classname>, <classname>@Size</classname> and
    <classname>@CheckCase</classname>:</para>

    <example>
      <title>Creating a composing constraint
      <classname>ValidLicensePlate</classname></title>

      <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.constraintcomposition;

@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
@Documented
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter04.constraintcomposition.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</programlisting>
    </example>

    <para>To do so, we just have to annotate the constraint declaration with
    its comprising constraints (btw. that's exactly why we allowed annotation
    types as target for the <classname>@CheckCase</classname> annotation). As
    no additional validation is required for the
    <classname>@ValidLicensePlate</classname> annotation itself, we don't
    declare a validator within the <classname>@Constraint </classname>meta
    annotation.</para>

    <para>Using the new composed constraint at the
    <property>licensePlate</property> field is fully equivalent to the
    previous version, where we declared the three constraints directly at the
    field itself:</para>

    <example>
      <title>Application of composing constraint
      <classname>ValidLicensePlate</classname></title>

      <programlisting language="JAVA" role="JAVA">package org.hibernate.validator.referenceguide.chapter04.constraintcomposition;

public class Car {

	@ValidLicensePlate
	private String licensePlate;

	//...
}</programlisting>
    </example>

    <para>The set of <classname>ConstraintViolations</classname> retrieved
    when validating a <classname>Car</classname> instance will contain an
    entry for each violated composing constraint of the
    <classname>@ValidLicensePlate</classname> constraint. If you rather prefer
    a single <classname>ConstraintViolation</classname> in case any of the
    composing constraints is violated, the
    <classname>@ReportAsSingleViolation</classname> meta constraint can be
    used as follows:</para>

    <example>
      <title>Usage of <classname>@ReportAsSingleViolation</classname></title>

      <programlisting language="JAVA" role="JAVA">//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter04.constraintcomposition.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</programlisting>
    </example>
  </section>
</chapter>
