<?xml version="1.0" encoding="UTF-8"?>
<!--
	~ JBoss, Home of Professional Open Source
	~ Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
	~ by the @authors tag. See the copyright.txt in the distribution for a
	~ full listing of individual contributors.
	~
	~ Licensed under the Apache License, Version 2.0 (the "License");
	~ you may not use this file except in compliance with the License.
	~ You may obtain a copy of the License at
	~ http://www.apache.org/licenses/LICENSE-2.0
	~ Unless required by applicable law or agreed to in writing, software
	~ distributed under the License is distributed on an "AS IS" BASIS,
	~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	~ See the License for the specific language governing permissions and
	~ limitations under the License.
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hv.ent">
%BOOK_ENTITIES;
]>
<chapter id="validator-usingvalidator">
  <title>Validation step by step</title>

  <para>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - field-, property-, and class-level
    annotations.</para>

    <note>
      <para>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <classname>java.lang.annotation.Target</classname>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <xref
      linkend="validator-customconstraints" /> for more information.</para>
    </note>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can be expressed by annotating a field of a class.
      <xref linkend="example-field-level" /> shows a field level configuration
      example:</para>

      <example id="example-field-level">
        <title>Field level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be validated. This means the bean validation
      provider directly accesses the instance variable and does not invoke the
      property accessor method also if such a method exists.</para>

      <note>
        <para>The access type (private, protected or public) does not
        matter.</para>
      </note>

      <note>
        <para>Static fields and properties cannot be validated.</para>
      </note>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <xref linkend="example-property-level" /> uses
      the same entity as in <xref linkend="example-field-level" />, however,
      property level constraints are used.<note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example id="example-property-level">
        <title>Property level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    @AssertTrue
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method. One
      advantage of annotating properties instead of fields is that the
      constraints become part of the constrained type's API that way and users
      are aware of the existing constraints without having to examine the
      type's implementation.</para>

      <tip>
        <para>It is recommended to stick either to field
        <emphasis>or</emphasis> property annotations within one class. It is
        not recommended to annotate a field <emphasis>and</emphasis> the
        accompanying getter method as this would cause the field to be
        validated twice.</para>
      </tip>
    </section>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <xref linkend="example-class-level" />
      we add the property <property>passengers</property> to the class
      <classname>Car</classname>. We also add the constraint
      <classname>PassengerCount</classname> on the class level. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints" />). For now we it is enough to
      know that <classname>PassengerCount</classname> will ensure that there
      cannot be more passengers in a car than there are seats.</para>

      <example id="example-class-level">
        <title>Class level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@PassengerCount
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    private List&lt;Person&gt; passengers;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
      </example>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Constraint inheritance using RentalCar</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> is now extended by
      <classname>RentalCar</classname> with the additional property
      <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> is validated, but also the constraint
      on <property>manufacturer</property> from the parent class.</para>

      <para>The same would hold true, if <classname>Car</classname> were an
      interface implemented by <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      referenced objects annotated with <classname>@Valid</classname> will be
      validated as well (as will be their children etc.). See <xref
      linkend="example-car-with-driver" />.</para>

      <example>
        <title>Class Person</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    @NotNull
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example id="example-car-with-driver">
        <title>Adding a driver to the car</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that</para>

      <itemizedlist>
        <listitem>
          <para>are arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs.</para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In <xref linkend="section-validator-instance" />
    we will first show how to obtain an <classname>Validator</classname>
    instance. Afterwards we will learn how to use the different methods of the
    <classname>Validator</classname> interface.</para>

    <section id="section-obtaining-validator">
      <title>Obtaining a <classname>Validator</classname> instance</title>

      <para>The first step towards validating an entity instance is to get
      hold of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The easiest way is to use the
      static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:</para>

      <example>
        <title>Validation.buildDefaultValidatorFactory()</title>

        <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</programlisting>
      </example>

      <para>For other ways of obtaining a Validator instance see <xref
      linkend="validator-bootstrapping" />. For now we just want to see how we
      can use the <classname>Validator</classname> instance to validate entity
      instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</para>

      <para>All three methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty,
      if the validation succeeds. Otherwise a
      <classname>ConstraintViolation</classname> instance is added for each
      violated constraint.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group
      (<classname>javax.validation.groups.Default</classname>) will be used.
      We will go into more detail on the topic of validation groups in <xref
      linkend="validator-usingvalidator-validationgroups" /></para>

      <section>
        <title><methodname>validate</methodname></title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given entity instance (see <xref
        linkend="example-validator-validate" /> ).</para>

        <example id="example-validator-validate">
          <title>Usage of
          <methodname>Validator.validate()</methodname></title>

          <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>
      </section>

      <section>
        <title><methodname>validateProperty</methodname></title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateProperty()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, "manufacturer");

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para><methodname>Validator.validateProperty</methodname> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <xref linkend="section-presentation-layer" />).</para>
      </section>

      <section>
        <title><methodname>validateValue</methodname></title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateValue()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, "manufacturer", null);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <note>
          <para><classname>@Valid</classname> is not honored by
          <methodname>validateProperty()</methodname> or
          <methodname>validateValue()</methodname>.</para>
        </note>
      </section>
    </section>

    <section>
      <title><classname>ConstraintViolation</classname> methods</title>

      <para>Now it is time to have a closer look at what a
      <classname>ConstraintViolation</classname>. Using the different methods
      of <classname>ConstraintViolation</classname> a lot of useful
      information about the cause of the validation failure can be determined.
      <xref linkend="table-constraint-violation" /> gives an overview of these
      methods:</para>

      <table id="table-constraint-violation">
        <title>The various <classname>ConstraintViolation</classname>
        methods</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Method</entry>

              <entry>Usage</entry>

              <entry>Example (referring to <xref
              linkend="example-validator-validate" />)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname>getMessage()</methodname></entry>

              <entry>The interpolated error message.</entry>

              <entry>may not be null</entry>
            </row>

            <row>
              <entry><methodname>getMessageTemplate()</methodname></entry>

              <entry>The non-interpolated error message.</entry>

              <entry>{javax.validation.constraints.NotNull.message}</entry>
            </row>

            <row>
              <entry><methodname>getRootBean()</methodname></entry>

              <entry>The root bean being validated.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getRootBeanClass()</methodname></entry>

              <entry>The class of the root bean being validated.</entry>

              <entry>Car.class</entry>
            </row>

            <row>
              <entry><methodname>getLeafBean()</methodname></entry>

              <entry>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getPropertyPath()</methodname></entry>

              <entry>The property path to the value from root bean.</entry>

              <entry></entry>
            </row>

            <row>
              <entry><methodname>getInvalidValue()</methodname></entry>

              <entry>The value failing to pass the constraint.</entry>

              <entry>passengers</entry>
            </row>

            <row>
              <entry><methodname>getConstraintDescriptor()</methodname></entry>

              <entry>Constraint metadata reported to fail.</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="section-message-interpolation">
      <title>Message interpolation</title>

      <para>As we will see in <xref linkend="validator-customconstraints" />
      each constraint definition must define a default message descriptor.
      This message can be overridden at declaration time using the
      <methodname>message</methodname> attribute of the constraint. You can
      see this in <xref linkend="example-driver" />. This message descriptors
      get interpolated when a constraint validation fails using the configured
      <classname>MessageInterpolator</classname>. The interpolator will try to
      resolve any message parameters, meaning string literals enclosed in
      braces. In order to resolve these parameters Hibernate Validator's
      default <classname>MessageInterpolator</classname> first recursively
      resolves parameters against a custom
      <classname>ResourceBundle</classname> called
      <filename>ValidationMessages.properties</filename> at the root of the
      classpath (It is up to you to create this file). If no further
      replacements are possible against the custom bundle the default
      <classname>ResourceBundle</classname> under
      <filename>/org/hibernate/validator/ValidationMessages.properties</filename>
      gets evaluated. If a replacement occurs against the default bundle the
      algorithm looks again at the custom bundle (and so on). Once no further
      replacements against these two resource bundles are possible remaining
      parameters are getting resolved against the attributes of the constraint
      to be validated.</para>

      <para>Since the braces { and } have special meaning in the messages they
      need to be escaped if they are used literally. The following The
      following rules apply:<itemizedlist>
          <listitem>
            <para>\{ is considered as the literal {</para>
          </listitem>

          <listitem>
            <para>\} is considered as the literal }</para>
          </listitem>

          <listitem>
            <para>\\ is considered as the literal \</para>
          </listitem>
        </itemizedlist></para>

      <para>If the default message interpolator does not fit your requirements
      it is possible to plug a custom
      <classname>MessageInterpolator</classname> when the
      <classname>ValidatorFactory</classname> gets created. This can be seen
      in <xref linkend="validator-bootstrapping" />.</para>
    </section>
  </section>

  <section id="validator-usingvalidator-validationgroups">
    <title>Validating groups</title>

    <para>Groups allow you to restrict the set of constraints applied during
    validation. This makes for example wizard like validation possible where
    in each step only a specified subset of constraints get validated. The
    groups targeted are passed as var-args parameters to
    <methodname>validate</methodname>,
    <methodname>validateProperty</methodname> and
    <methodname>validateValue</methodname>. Let's have a look at an extended
    <classname>Car</classname> with <classname>Driver</classname> example.
    First we have the class <classname>Person</classname> (<xref
    linkend="example-person" />) which has a <classname>@NotNull
    </classname>constraint on <property>name</property>. Since no group is
    specified for this annotation its default group is
    <classname>javax.validation.groups.Default</classname>.</para>

    <note>
      <para>When more than one group is requested, the order in which the
      groups are evaluated is not deterministic. If no group is specified the
      default group <classname>javax.validation.groups.Default</classname> is
      assumed.</para>
    </note>

    <example id="example-person">
      <title>Person</title>

      <programlisting language="JAVA" role="JAVA">public class Person {
    @NotNull
    private String name;

    public Person(String name) {
        this.name = name;
    }
    // getters and setters ...
}</programlisting>
    </example>

    <para>Next we have the class <classname>Driver</classname> (<xref
    linkend="example-driver" />) extending <classname>Person</classname>. Here
    we are adding the properties <property>age</property> and
    <property>hasDrivingLicense</property>. In order to drive you must be at
    least 18 (<classname>@Min(18)</classname>) and you must have a driving
    license (<classname>@AssertTrue</classname>). Both constraints defined on
    these properties belong to the group <classname>DriverChecks</classname>.
    As you can see in <xref linkend="example-group-interfaces" /> the group
    <classname>DriverChecks</classname> is just a simple tagging interface.
    Using interfaces makes the usage of groups type safe and allows for easy
    refactoring. It also means that groups can inherit from each other via
    class inheritance.</para>

    <example id="example-driver">
      <title>Driver</title>

      <programlisting language="JAVA" role="JAVA">public class Driver extends Person {
    @Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)
    public int age;

    @AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</programlisting>
    </example>

    <example id="example-group-interfaces">
      <title>Group interfaces</title>

      <programlisting language="JAVA" role="JAVA">public interface DriverChecks {
}

public interface CarChecks {
}</programlisting>
    </example>

    <para>Last but not least we add the property
    <property>passedVehicleInspection</property> to the
    <classname>Car</classname> class (<xref linkend="example-car" />)
    indicating whether a car passed the road worthy tests.</para>

    <example id="example-car">
      <title>Car</title>

      <programlisting language="JAVA" role="JAVA">public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    @AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</programlisting>
    </example>

    <para>Overall three different groups are used in our example.
    <property>Person.name</property>, <property>Car.manufacturer</property>,
    <property>Car.licensePlate</property> and
    <property>Car.seatCount</property> all belong to the
    <classname>Default</classname> group. <property>Driver.age</property> and
    <property>Driver.hasDrivingLicense</property> belong to
    <classname>DriverChecks</classname> and last but not least
    <property>Car.passedVehicleInspection</property> belongs to the group
    <classname>CarChecks</classname>. <xref linkend="example-drive-away" />
    shows how passing different group combinations to the
    <methodname>Validator.validate</methodname> method result in different
    validation results.</para>

    <example id="example-drive-away">
      <title>Drive away</title>

      <programlisting language="JAVA" role="JAVA">public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</programlisting>
    </example>

    <para>First we create a car and validate it using no explicit group. There
    are no validation errors, even though the property
    <property>passedVehicleInspection</property> is per default
    <constant>false</constant>. However, the constraint defined on this
    property does not belong to the default group. Next we just validate the
    <classname>CarChecks</classname> group which will fail until we make sure
    that the car passes the vehicle inspection. When we then add a driver to
    the car and validate against <classname>DriverChecks</classname> we get
    again a constraint violation due to the fact that the driver has not yet
    passed the driving test. Only after setting
    <property>passedDrivingTest</property> to true the validation against
    <classname>DriverChecks</classname> will pass.</para>

    <para>Last but not least, we show that all constraints are passing by
    validating against all defined groups.</para>

    <section>
      <title>Group sequences</title>

      <para>By default, constraints are evaluated in no particular order and
      this regardless of which groups they belong to. In some situations,
      however, it is useful to control the order of the constraint evaluation.
      In our example from <xref
      linkend="validator-usingvalidator-validationgroups" /> we could for
      example require that first all default car constraints are passing
      before we check the road worthiness of the car. Finally before we drive
      away we check the actual driver constraints. In order to implement such
      an order one would define a new interface and annotate it with
      <classname>@GroupSequence</classname> defining the order in which the
      groups have to be validated.</para>

      <note>
        <para>If at least one constraints fails in a sequenced group none of
        the constraints of the following groups in the sequence get
        validated.</para>
      </note>

      <example>
        <title>Interface with @GroupSequence</title>

        <programlisting language="JAVA" role="JAVA">@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})
public interface OrderedChecks {
}</programlisting>
      </example>

      <para><warning>
          <para>Groups defining a sequence and groups composing a sequence
          must not be involved in a cyclic dependency either directly or
          indirectly, either through cascaded sequence definition or group
          inheritance. If a group containing such a circularity is evaluated,
          a <classname>GroupDefinitionException</classname> is raised.</para>
        </warning>The usage of the new sequence could then look like in <xref
      linkend="example-group-sequence" />.</para>

      <example id="example-group-sequence">
        <title>Usage of a group sequence</title>

        <programlisting language="JAVA" role="JAVA">@Test
public void testOrderedChecks() {
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    car.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    car.setDriver( john );

    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
}</programlisting>
      </example>
    </section>

    <section id="section-default-group-class">
      <title>Redefining the default group sequence of a class</title>

      <section>
        <title>@GroupSequence</title>

        <para>The <classname>@GroupSequence</classname> annotation also
        fulfills a second purpose. It allows you to redefine what the
        <constant>Default</constant> group means for a given class. To
        redefine <classname>Default</classname> for a given class, add a
        <classname>@GroupSequence</classname> annotation to the class. The
        defined groups in the annotation express the sequence of groups that
        substitute <classname>Default</classname> for this class. <xref
        linkend="example-rental-car" /> introduces a new class
        <classname>RentalCar</classname> with a redefined default group. With
        this definition the check for all three groups can be rewritten as
        seen in <xref
        linkend="example-testOrderedChecksWithRedefinedDefault" />.</para>

        <example id="example-rental-car">
          <title>RentalCar with @GroupSequence</title>

          <programlisting language="JAVA" role="JAVA">@GroupSequence({ RentalCar.class, CarChecks.class, DriverChecks.class })
public class RentalCar extends Car {
    private boolean rented;    

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

   public boolean isRented() {
        return rented;
    }

    public void setRented(booelan rented) {
        this.rented = rented;
    }
}</programlisting>
        </example>

        <example id="example-testOrderedChecksWithRedefinedDefault">
          <title>testOrderedChecksWithRedefinedDefault</title>

          <programlisting language="JAVA" role="JAVA">@Test
public void testOrderedChecksWithRedefinedDefault() {
    RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
    rentalCar.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    rentalCar.setDriver( john );

    assertEquals( 0, validator.validate( rentalCar, Default.class ).size() );
}</programlisting>
        </example>

        <note>
          <para>Due to the fact that there cannot be a cyclic dependency in
          the group and group sequence definitions one cannot just add
          <classname>Default</classname> to the sequence redefining
          <classname>Default</classname> for a class. Instead the class itself
          should be added!</para>
        </note>
      </section>

      <section>
        <title>@GroupSequenceProvider</title>

        <para>The <classname>@javax.validation.GroupSequence</classname>
        annotation is a standardized Bean Validation annotation. As seen in
        the previous section it allows you to statically redefine the default
        group sequence for a class. Hibernate Validator also offers a custom,
        non standardized annotation -
        <classname>org.hibernate.validator.group.GroupSequenceProvider
        </classname>- which allows for dynamic redefinition of the default
        group sequence. Using the rental car scenario again, one could
        dynamically add the driver checks depending on whether the car is
        rented or not. <xref
        linkend="example-rental-car-group-sequence-provider" /> and <xref
        linkend="example-group-sequence-provider-implementation" /> show how
        this use-case would be implemented.</para>

        <example id="example-rental-car-group-sequence-provider">
          <title>RentalCar with @GroupSequenceProvider</title>

          <programlisting language="JAVA" role="JAVA">@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {
    private boolean rented;    

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

   public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}</programlisting>
        </example>

        <example id="example-group-sequence-provider-implementation" label="">
          <title>DefaultGroupSequenceProvider implementation</title>

          <programlisting language="JAVA" role="JAVA">public class RentalCarGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {
    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {
        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();
        defaultGroupSequence.add( RentalCar.class, CarChecks.class );

        if ( car != null &amp;&amp; car.isRented() ) {
            defaultGroupSequence.add( DriverChecks.class );
        }

        return defaultGroupSequence;
    }
}</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section id="validator-defineconstraints-builtin">
    <title>Built-in constraints</title>

    <para>Hibernate Validator comprises a basic set of commonly used
    constraints. These are foremost the constraints defined by the Bean
    Validation specification (see <xref linkend="table-spec-constraints" />).
    Additionally, Hibernate Validator provides useful custom constraints (see
    <xref linkend="table-custom-constraints" />).</para>

    <section id="validator-defineconstraints-spec">
      <title>Bean Validation constraints</title>

      <para><xref linkend="table-spec-constraints" /> shows purpose and
      supported data types of all constraints specified in the Bean Validation
      API. All these constraints apply to the field/property level, there are
      no class-level constraints defined in the Bean Validation specification.
      If you are using the Hibernate object-relational mapper, some of the
      constraints are taken into account when creating the DDL for your model
      (see column "Hibernate metadata impact").</para>

      <note>
        <para>Hibernate Validator allows some constraints to be applied to
        more data types than required by the Bean Validation specification
        (e.g. @Max can be applied to <classname>Strings</classname>). Relying
        on this feature can impact portability of your application between
        Bean Validation providers.</para>
      </note>

      <table id="table-spec-constraints">
        <title>Bean Validation constraints</title>

        <tgroup cols="4">
          <colspec align="left" />

          <colspec align="left" />

          <colspec align="left" />

          <colspec align="left" />

          <thead>
            <row>
              <entry>Annotation</entry>

              <entry>Supported data types</entry>

              <entry>Use</entry>

              <entry>Hibernate metadata impact</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>@AssertFalse</entry>

              <entry><classname>Boolean</classname>,
              <classname>boolean</classname></entry>

              <entry>Checks that the annotated element is
              <constant>false</constant>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@AssertTrue</entry>

              <entry><classname>Boolean</classname>,
              <classname>boolean</classname></entry>

              <entry>Checks that the annotated element is
              <constant>true</constant>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@DecimalMax</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number</classname>.</entry>

              <entry>The annotated element must be a number whose value must
              be lower or equal to the specified maximum. The parameter value
              is the string representation of the max value according to the
              <classname>BigDecimal</classname> string representation.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@DecimalMin</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number</classname>.</entry>

              <entry>The annotated element must be a number whose value must
              be higher or equal to the specified minimum. The parameter value
              is the string representation of the min value according to the
              <classname>BigDecimal</classname> string representation.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Digits(integer=, fraction=)</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV: any sub-type of
              <classname>Number</classname>.</entry>

              <entry>Checks whether the annoted value is a number having up to
              <literal>integer</literal> digits and
              <literal>fraction</literal> fractional digits.</entry>

              <entry>Define column precision and scale.</entry>
            </row>

            <row>
              <entry>@Future</entry>

              <entry><classname>java.util.Date</classname>,
              <classname>java.util.Calendar</classname>; Additionally
              supported by HV, if the <ulink
              url="http://joda-time.sourceforge.net/">Joda Time</ulink>
              date/time API is on the class path: any implementations of
              <classname>ReadablePartial</classname> and
              <classname>ReadableInstant</classname>.</entry>

              <entry>Checks whether the annotated date is in the
              future.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Max</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV:
              <classname>String</classname> (the numeric value represented by
              a String is evaluated), any sub-type of
              <classname>Number</classname>.</entry>

              <entry>Checks whether the annotated value is less than or equal
              to the specified maximum.</entry>

              <entry>Add a check constraint on the column.</entry>
            </row>

            <row>
              <entry>@Min</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types. Additionally supported by HV:
              <classname>String</classname> (the numeric value represented by
              a String is evaluated), any sub-type of
              <classname>Number</classname>.</entry>

              <entry>Checks whether the annotated value is higher than or
              equal to the specified minimum.</entry>

              <entry>Add a check constraint on the column.</entry>
            </row>

            <row>
              <entry>@NotNull</entry>

              <entry>Any type</entry>

              <entry>Checks that the annotated value is not
              <constant>null.</constant></entry>

              <entry>Column(s) are not null.</entry>
            </row>

            <row>
              <entry>@Null</entry>

              <entry>Any type</entry>

              <entry>Checks that the annotated value is
              <constant>null.</constant></entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Past</entry>

              <entry><classname>java.util.Date</classname>,
              <classname>java.util.Calendar</classname>; Additionally
              supported by HV, if the <ulink
              url="http://joda-time.sourceforge.net/">Joda Time</ulink>
              date/time API is on the class path: any implementations of
              <classname>ReadablePartial</classname> and
              <classname>ReadableInstant</classname>.</entry>

              <entry>Checks whether the annotated date is in the past.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Pattern(regex=, flag=)</entry>

              <entry><classname>String</classname></entry>

              <entry>Checks if the annotated string matches the regular
              expression <parameter>regex</parameter> considering the given
              flag <parameter>match</parameter>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Size(min=, max=)</entry>

              <entry><classname>String</classname>,
              <classname>Collection</classname>, <classname>Map</classname>
              and <classname>arrays</classname></entry>

              <entry>Checks if the annotated element's size is between min and
              max (inclusive).</entry>

              <entry>Column length will be set to max.</entry>
            </row>

            <row>
              <entry>@Valid</entry>

              <entry>Any non-primitive type</entry>

              <entry>Performs validation recursively on the associated object.
              If the object is a collection or an array, the elements are
              validated recursively. If the object is a map, the value
              elements are validated recursively.</entry>

              <entry>none</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <note>
        <para>On top of the parameters indicated in <xref
        linkend="table-spec-constraints" /> each constraint supports the
        parameters <parameter>message</parameter>,
        <parameter>groups</parameter> and <parameter>payload</parameter>. This
        is a requirement of the Bean Validation specification.</para>
      </note>
    </section>

    <section id="validator-defineconstraints-hv-constraints">
      <title>Additional constraints</title>

      <para>In addition to the constraints defined by the Bean Validation API
      Hibernate Validator provides several useful custom constraints which are
      listed in <xref linkend="table-custom-constraints" />. With one
      exception also these constraints apply to the field/property level, only
      @ScriptAssert is a class-level constraint.</para>

      <table id="table-custom-constraints">
        <title>Custom constraints provided by Hibernate Validator</title>

        <tgroup cols="4">
          <colspec align="left" />

          <colspec align="left" />

          <colspec align="left" />

          <colspec align="left" />

          <thead>
            <row>
              <entry>Annotation</entry>

              <entry>Supported data types</entry>

              <entry>Use</entry>

              <entry>Hibernate metadata impact</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry>@CreditCardNumber</entry>

              <entry><classname>String</classname></entry>

              <entry>Checks that the annotated string passes the Luhn checksum
              test. Note, this validation aims to check for user mistakes, not
              credit card validity! See also <ulink
              url="http://www.merriampark.com/anatomycc.htm">Anatomy of Credit
              Card Numbers</ulink>.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Email</entry>

              <entry><classname>String</classname></entry>

              <entry>Checks whether the specified string is a valid email
              address.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Length(min=, max=)</entry>

              <entry><classname>String</classname></entry>

              <entry>Validates that the annotated string is between
              <parameter>min</parameter> and <parameter>max</parameter>
              included.</entry>

              <entry>Column length will be set to max.</entry>
            </row>

            <row>
              <entry>@NotBlank</entry>

              <entry><classname>String</classname></entry>

              <entry>Checks that the annotated string is not null and the
              trimmed length is greater than 0. The difference to @NotEmpty is
              that this constraint can only be applied on strings and that
              trailing whitespaces are ignored.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@NotEmpty</entry>

              <entry><classname>String</classname>,
              <classname>Collection</classname>, <classname>Map</classname>
              and arrays</entry>

              <entry>Checks whether the annotated element is not
              <constant>null</constant> nor empty.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@Range(min=, max=)</entry>

              <entry><classname>BigDecimal</classname>,
              <classname>BigInteger</classname>,
              <classname>String</classname>, <classname>byte</classname>,
              <classname>short</classname>, <classname>int</classname>,
              <classname>long</classname> and the respective wrappers of the
              primitive types</entry>

              <entry>Checks whether the annotated value lies between
              (inclusive) the specified minimum and maximum.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@SafeHtml(whitelistType=, additionalTags=)</entry>

              <entry><classname>CharSequence</classname></entry>

              <entry>Checks whether the annotated value contains potentially
              malicious fragments such as <code>&lt;script/&gt;</code>. In
              order to use this constraint, the <ulink
              url="http://jsoup.org/">jsoup</ulink> library must be part of
              the class path. With the <parameter>whitelistType</parameter>
              attribute predefined whitelist types can be chosen. You can also
              specify additional html tags for the whitelist with the
              <parameter>additionalTags</parameter> attribute.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@ScriptAssert(lang=, script=, alias=)</entry>

              <entry>Any type</entry>

              <entry>Checks whether the given script can successfully be
              evaluated against the annotated element. In order to use this
              constraint, an implementation of the Java Scripting API as
              defined by JSR 223 ("Scripting for the
              Java<superscript>TM</superscript> Platform") must part of the
              class path. This is automatically the case when running on Java
              6. For older Java versions, the JSR 223 RI can be added manually
              to the class path.The expressions to be evaluated can be written
              in any scripting or expression language, for which a JSR 223
              compatible engine can be found in the class path.</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>@URL(protocol=, host=, port=, regexp=, flags=)</entry>

              <entry><classname>String</classname></entry>

              <entry>Checks if the annotated string is a valid URL according
              to RFC2396. If any of the optional parameters
              <parameter>protocol</parameter>, <parameter>host</parameter> or
              <parameter>port</parameter> are specified, the corresponding URL
              fragments must match the specified values. The optional
              parameters <parameter>regexp</parameter> and
              <parameter>flags</parameter> allow to specify an additional
              regular expression (including regular expression flags) which
              the URL must match.</entry>

              <entry>none</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In some cases neither the Bean Validation constraints nor the
      custom constraints provided by Hibernate Validator will fulfill your
      requirements completely. In this case you can literally in a minute
      write your own constraints. We will discuss this in <xref
      linkend="validator-customconstraints" />.</para>
    </section>
  </section>
</chapter>
