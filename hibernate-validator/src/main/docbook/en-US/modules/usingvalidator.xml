<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="validator-usingvalidator">
  <title>Validation step by step</title>

  <para>In this chapter we will see in more detail how to use Bean Validation
  to validate constraints for a given entity model. We will also learn which
  default constraints the specification provides and which additional
  constraints are only provided by Hibernate Validator. Let's start with how
  to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate" revision="1">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - class-, field- and property-level
    annotations.</para>

    <note>
      <para>Not all constraints can be placed on any of these levels. In fact
      all the default constraints defined by Bean Validation cannot be places
      at class level. The java.lang.annotation.Target annotation placed on the
      constraint annotation itself determines on which elements a constraint
      can be placed. See also <xref
      linkend="validator-customconstraints" /></para>
    </note>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>When a constraint annotation is placed on class level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In the following example we add the
      properties <property>horsePower</property> and
      <property>kiloWatt</property> to the class <classname>Car</classname>.
      We also add the constraint ValidCar to the class itself. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints" />). For now we can just assume
      that this constraints will for example ensure that the value for
      <property>kiloWatt</property> is 0.7456 *
      <property>horsePower</property>.</para>

      <para><example xreflabel="Car-example">
          <title>Class Car with added horsePower and killoWatt
          properties</title>

          <programlisting language="Java">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

<emphasis role="bold">@ValidCar</emphasis>
public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    private String manufacturer;

    <emphasis role="bold">@NotNull</emphasis>
    <emphasis role="bold">@Size(min = 2, max = 14)</emphasis>
    private String licensePlate;

    <emphasis role="bold">@Min(2)</emphasis>
    private int seatCount;

    private int horsePower;

    private double kiloWatt;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
        </example></para>
    </section>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can also be expressed by annotating a field of a
      class. The following listing shows a simple example:</para>

      <example>
        <title>Example for field level constraints</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    private String manufacturer;

    public Car(String manufacturer) {
        this.manufacturer = manufacturer;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be value. This means the bean validation provider
      accesses the instance variable directly.</para>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example>
        <title>Example for property level constraints</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    <emphasis role="bold">@NotNull</emphasis>
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    <emphasis role="bold">@AssertTrue</emphasis>
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method.</para>

      <para>Generally it is recommended to stick either to field
      <emphasis>or</emphasis> property annotation within one class. It is not
      recommended to annotate a field <emphasis>and</emphasis> the
      accompanying getter method as this would cause the field to be validated
      twice.</para>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Example for constraint inheritance using RentalCar</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> from <link
      linkend="example-class-car">the getting started section</link> is now
      extended by <classname>RentalCar</classname> with the additional
      property <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> would be validated, but also the
      constraint at <property>manufacturer</property> from the parent
      class.</para>

      <para>The same would hold true, if <classname>Car</classname> was an
      interface, that is implemented by
      <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      objects but also complete object graphs. To do so just annotate a field
      or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      objects referenced by a field/property annotated with
      <classname>@Valid</classname> will be validated as well (as will be
      their children etc.). The following shows a simple example:</para>

      <example>
        <title>Class Person</title>

        <programlisting>
package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    <emphasis role="bold">@NotNull</emphasis>
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example>
        <title>Adding a driver to the car</title>

        <programlisting>package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    <emphasis role="bold">@Valid</emphasis>
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that are</para>

      <itemizedlist>
        <listitem>
          <para>arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting>package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.hibernate.validator.constraints.NotEmpty;

public class Car {

    @NotNull
    @Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated now, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs.</para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate" revision="1">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In the following we first will show how to
    obtain an <classname>Validator</classname> instance using the different
    bootstrapping mechanisms. Afterwards we will learn how to use the
    different methods of the <classname>Validator</classname>
    interface.</para>

    <section>
      <title>Obtaining a Validator instance</title>

      <para>The first step towards validating a class instance is to get hold
      of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The by far easiest way is to
      use the static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:<example>
          <title>Validation.buildDefaultValidatorFactory()</title>

          <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</programlisting>
        </example>You can also use the method
      <methodname>Validation.byDefaultProvider()</methodname> which will allow
      you to configure several aspects of the created Validator
      instance:<example>
          <title>Validation.byDefaultProvider()</title>

          <programlisting>Configuration&lt;?&gt; config = Validation.byDefaultProvider().configure();
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();
</programlisting>
        </example>We will learn more about
      <classname>MessageInterpolator</classname> and
      <classname>TraversableResolver</classname> in later chapters.</para>

      <para>Last but not least you can ask for a Configuration object of a
      specific Bean Validation provider. This is useful if you have more than
      one Bean Validation provider in your classpath. In this situation you
      can make an explicit choice about which implementation to use. In the
      case of Hibernate Validator the Validator creation looks like:<example>
          <title>Validation.byProvider( HibernateValidator.class )</title>

          <programlisting>ValidatorConfiguration config = Validation.byProvider( HibernateValidator.class ).configure;
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();</programlisting>
        </example></para>

      <para><note>
          <para>The generated <classname>Validator</classname> instance is
          thread safe and can be cached.</para>
        </note>Now that we have a <classname>Validator</classname> instance,
      let's see how we can use it to validate class instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to validate entire object instances or only
      single properties of an instance.</para>

      <para>All of these methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>. The set will be
      empty, if the validation succeeded. Otherwise a
      <classname>ConstraintViolation</classname> object for each violated
      constraint will be added to the set.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group (<classname>javax.validation.Default</classname>) will
      be used. We will go into more detail on the topic of validation groups
      in <xref linkend="validator-usingvalidator-validationgroups" /></para>

      <section>
        <title><methodname>validate</methodname></title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given entity instance. The
        following listing shows an example:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validate()</methodname></title>

          <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>
      </section>

      <section>
        <title><methodname>validateProperty</methodname></title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name. @Valid is not honored by this
        method.</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateProperty()</methodname></title>

          <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, "manufacturer");

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para><methodname>Validator.validateProperty</methodname> is for
        example used in the integration of Bean Validation into JSF 2.</para>
      </section>

      <section>
        <title><methodname>validateValue</methodname></title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateValue()</methodname></title>

          <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, "manufacturer", null);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para>@Valid is not honored by this method.</para>
      </section>
    </section>

    <section>
      <title><classname>ConstraintViolation</classname>s explained</title>

      <para>Now it is time to have a closer look at what a failing validation
      returns - a <classname>ConstraintViolation</classname>. Using the
      different methods of a <classname>ConstraintViolation</classname>
      instance a lot of useful information about the reason of the validation
      failure can be determined.</para>

      <table>
        <title>The various <classname>ConstraintViolation</classname>
        methods</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Method</entry>

              <entry>Usage</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname>getMessage()</methodname></entry>

              <entry>The interpolated error message.</entry>
            </row>

            <row>
              <entry><methodname>getMessageTemplate()</methodname></entry>

              <entry>The non-interpolated error message.</entry>
            </row>

            <row>
              <entry><methodname>getRootBean()</methodname></entry>

              <entry>The root bean being validated.</entry>
            </row>

            <row>
              <entry><methodname>getRootBeanClass()</methodname></entry>

              <entry>The class of the root bean being validated.</entry>
            </row>

            <row>
              <entry><methodname>getLeafBean()</methodname></entry>

              <entry>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</entry>
            </row>

            <row>
              <entry><methodname>getPropertyPath()</methodname></entry>

              <entry>The property path to the value from root bean.</entry>
            </row>

            <row>
              <entry><methodname>getInvalidValue()</methodname></entry>

              <entry>The value failing to pass the constraint.</entry>
            </row>

            <row>
              <entry><methodname>getConstraintDescriptor()</methodname></entry>

              <entry>Constraint metadata reported to fail.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>A word about message interpolation</title>

      <para></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validationgroups" revision="1">
    <title>Using groups</title>

    <para>Groups allow you to restrict the set of constraints applied during
    validation. This allows for example for wizard like validation where for
    each step only a specified subset of the defined constraints get
    validated. The groups targeted are passed as var-args parameters to
    <methodname>validate</methodname>,
    <methodname>validateProperty</methodname> and
    <methodname>validateValue</methodname>. When more than one group is
    requested, the order in which the groups are evaluated is not
    deterministic. If no group is specified the default group
    <classname>javax.validation.Default</classname> is assumed. Let's have a
    look at a slightly extended <classname>Car</classname> with
    <classname>Driver</classname> example.</para>

    <para><example>
        <title>Person</title>

        <programlisting>public class Person {
    @NotNull
    private String name;

    public Person(String name) {
        this.name = name;
    }

    // getters and setters ...
}</programlisting>
      </example><example>
        <title>Driver</title>

        <programlisting>public class Driver extends Person {
    <emphasis role="bold">@Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)</emphasis>
    public int age;

    <emphasis role="bold">@AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)</emphasis>
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</programlisting>
      </example><example>
        <title>Car</title>

        <programlisting>public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    <emphasis role="bold">@AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)</emphasis>
    private boolean passedVehicleInspection;

    <emphasis role="bold">@Valid</emphasis>
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</programlisting>
      </example><example>
        <title>The actual group interfaces</title>

        <programlisting>public interface DriverChecks {
}


public interface CarChecks {
}</programlisting>
      </example><example>
        <title>Drive away</title>

        <programlisting>public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</programlisting>
      </example></para>

    <section revision="1">
      <title>Group sequences</title>

      <para>By default, constraints are evaluated in no particular order and
      this regardless of which groups they belong to. It is however useful in
      some situations to control the order of constraints evaluation. There
      are often scenarios where a preliminary set of constraints should be
      evaluated prior to other constraints. ...</para>
    </section>
  </section>

  <section id="validator-defineconstraints-builtin" revision="2">
    <title>Built-in constraints</title>

    <para>Hibernate Validator implements all of the constraints specified in
    Bean Validation as well as some custom constraints. <xref
    linkend="table-builtin-constraints" /> list all built-in constraints
    available in Hibernate Validator.</para>

    <table id="table-builtin-constraints">
      <title>Built-in constraints</title>

      <tgroup cols="5">
        <colspec align="left" />

        <thead>
          <row>
            <entry>Annotation</entry>

            <entry>Part of Bean Validation Specification</entry>

            <entry>Apply on</entry>

            <entry>Use</entry>

            <entry>Hibernate Metadata impact</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>@AssertFalse</entry>

            <entry>yes</entry>

            <entry>field/property√ü</entry>

            <entry>check that the annotated element is
            <constant>false</constant>.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@AssertTrue</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>check that the annotated element is
            <constant>true</constant>.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@DecimalMax</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective warppers of the primtive types. </entry>

            <entry>The annotated element must be a number whose value must be
            lower or equal to the specified maximum. The parameter value is
            the string representation of the max value according to the
            <classname>BigDecimal</classname> string representation.</entry>

            <entry></entry>
          </row>

          <row>
            <entry>@DecimalMin</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective warppers of the primtive types.</entry>

            <entry>The annotated element must be a number whose value must be
            higher or equal to the specified maximum. The parameter value is
            the string representation of the min value according to the
            <classname>BigDecimal</classname> string representation.</entry>

            <entry></entry>
          </row>

          <row>
            <entry>@Digits(integer=, fraction=)</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective warppers of the primtive types. </entry>

            <entry>Check whether the property is a number having up to
            <literal>integer</literal> digits and <literal>fraction</literal>
            fractional digits.</entry>

            <entry>Define column precision and scale.</entry>
          </row>

          <row>
            <entry>@Future</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>java.util.Date</classname> and
            <classname>java.util.Calendar</classname>.</entry>

            <entry>Checks whether the annotated date is in the future.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Length(min=, max=)</entry>

            <entry>no</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Validate that the annotated string is between
            <parameter>min</parameter> and <parameter>max</parameter>
            included.</entry>

            <entry>Column length will be set to max.</entry>
          </row>

          <row>
            <entry>@Max</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective warppers of the primtive types.</entry>

            <entry>Checks whether the annoated value is less than or equal to
            the specified maximum.</entry>

            <entry>Add a check constraint on the column.</entry>
          </row>

          <row>
            <entry>@Min</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective warppers of the primtive types.</entry>

            <entry>Check whether the annoated value is higher than or equal to
            the specified minimum.</entry>

            <entry>Add a check constraint on the column.</entry>
          </row>

          <row>
            <entry>@NotNull</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>Check that the annoated value is not
            <constant>null.</constant></entry>

            <entry>Column(s) are not null.</entry>
          </row>

          <row>
            <entry>@NotEmpty</entry>

            <entry>no</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Check if the string is not <constant>null</constant> nor
            empty. </entry>

            <entry>Column(s) are not null (for String).</entry>
          </row>

          <row>
            <entry>@Past</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>java.util.Date</classname> and
            <classname>java.util.Calendar</classname>.</entry>

            <entry>Checks whether the annotated date is in the past.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Pattern(regex=, flag=)</entry>

            <entry>yes</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Check if the annotated string match the regular
            expression.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Size(min=, max=)</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>String</classname>, <classname>Collection</classname>,
            <classname>Map</classname> and
            <classname>arrays</classname>.</entry>

            <entry>Check if the annotated element size is between min and max
            (inclusive).</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Valid</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>Perform validation recursively on the associated
            object.</entry>

            <entry>none</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para>On top of the parameters indicated in <xref
      linkend="table-builtin-constraints" /> each constraint supports the
      parameters <parameter>message</parameter>, <parameter>groups</parameter>
      and <parameter>payload</parameter>.</para>
    </note>

    <para>In some cases these built-in constraints will not fulfill your
    requirements. In this case you can literally in a minute write your own
    constraints. We will discuss this in <xref
    linkend="validator-customconstraints" /></para>
  </section>
</chapter>
